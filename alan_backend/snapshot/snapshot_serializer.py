# Copyright 2025 ALAN Team and contributors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Patent Peace / Retaliation Notice:
#   As stated in Section 3 of the Apache 2.0 License, any entity that
#   initiates patent litigation (including a cross-claim or counterclaim)
#   alleging that this software or a contribution embodied within it
#   infringes a patent shall have all patent licenses granted herein
#   terminated as of the date such litigation is filed.

"""
State snapshot serializer using FlatBuffers.

This module implements serialization and deserialization of state snapshots
using FlatBuffers, providing a safe, efficient and cross-language compatible
format for TRS rollback and state persistence.

Features:
- Cross-platform compatibility with explicit endianness handling
- Schema versioning with CRC32 validation
- Portable IEEE-754 float representation
"""

import flatbuffers
import numpy as np
import struct
import sys
import zlib
from typing import Optional, Tuple, Dict, Any, NamedTuple, Union, List
import logging

from .compression import CompressMode, should_compress, compress, decompress, is_compressed

# Constants
SCHEMA_CRC32 = 0x8A7B4C3D  # CRC32 of the snapshot.fbs schema file
VERSION = 0x0200          # Version 2.0 in major.minor format
LITTLE_ENDIAN = 0         # Endianness flag value for little-endian
BIG_ENDIAN = 1            # Endianness flag value for big-endian

# Helper functions for version handling
def get_version() -> Tuple[int, int]:
    """Get the schema version as a (major, minor) tuple.
    
    Returns:
        Tuple of (major, minor) version numbers
    """
    major = (VERSION >> 8) & 0xFF
    minor = VERSION & 0xFF
    return (major, minor)

# Determine system endianness
IS_LITTLE_ENDIAN = sys.byteorder == 'little'

# Import generated FlatBuffer classes
# Note: These will be generated using the flatc compiler
# from the snapshot.fbs schema file
try:
    from alan_backend.snapshot.generated import SnapshotV2, ByteVector
except ImportError:
    logging.warning(
        "FlatBuffers generated code not found. Using placeholder implementation."
    )

    # Placeholder classes for development until flatc is run
    class SnapshotV2:
        """Placeholder for the generated SnapshotV2 class."""
        
        @staticmethod
        def StartSnapshotV2(builder):
            return builder.StartObject(9)  # 9 fields in the new schema
        
        @staticmethod
        def AddTheta(builder, theta):
            builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(theta), 0)
        
        @staticmethod
        def AddPTheta(builder, p_theta):
            builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(p_theta), 0)
        
        @staticmethod
        def AddSigma(builder, sigma):
            builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(sigma), 0)
        
        @staticmethod
        def AddPSigma(builder, p_sigma):
            builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(p_sigma), 0)
        
        @staticmethod
        def AddDtPhase(builder, dt_phase):
            builder.PrependFloat32Slot(4, dt_phase, 0.0)
        
        @staticmethod
        def AddDtSpin(builder, dt_spin):
            builder.PrependFloat32Slot(5, dt_spin, 0.0)
            
        @staticmethod
        def AddEndianness(builder, endianness):
            builder.PrependUint8Slot(6, endianness, 0)
            
        @staticmethod
        def AddSchemaCrc32(builder, crc32):
            builder.PrependUint32Slot(7, crc32, 0)
            
        @staticmethod
        def AddVersion(builder, version):
            builder.PrependUint16Slot(8, version, 0)
        
        @staticmethod
        def EndSnapshotV2(builder):
            return builder.EndObject()
        
        @staticmethod
        def GetRootAsSnapshotV2(buf, offset):
            return SnapshotV2Accessor(buf)
    
    class ByteVector:
        """Placeholder for the generated ByteVector class."""
        
        @staticmethod
        def StartByteVector(builder):
            return builder.StartObject(1)
        
        @staticmethod
        def AddData(builder, data):
            builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(data), 0)
        
        @staticmethod
        def EndByteVector(builder):
            return builder.EndObject()
        
        @staticmethod
        def CreateByteVector(builder, data):
            builder.StartVector(1, len(data), 1)
            # Insert in reverse order since FlatBuffers builds backwards
            for i in range(len(data) - 1, -1, -1):
                builder.PrependUint8(data[i])
            return builder.EndVector()
    
    class SnapshotV2Accessor:
        """Placeholder for the generated SnapshotV2 accessor class."""
        
        def __init__(self, buf):
            self.buf = buf
        
        def Theta(self):
            return ByteVectorAccessor(self.buf)
        
        def PTheta(self):
            return ByteVectorAccessor(self.buf)
        
        def Sigma(self):
            return ByteVectorAccessor(self.buf)
        
        def PSigma(self):
            return ByteVectorAccessor(self.buf)
        
        def DtPhase(self):
            return 0.01  # Placeholder
        
        def DtSpin(self):
            return 0.00125  # Placeholder
            
        def Endianness(self):
            return LITTLE_ENDIAN  # Placeholder
            
        def SchemaCrc32(self):
            return SCHEMA_CRC32  # Placeholder
        
        def Version(self):
            return VERSION  # Placeholder
    
    class ByteVectorAccessor:
        """Placeholder for the generated ByteVector accessor class."""
        
        def __init__(self, buf):
            self.buf = buf
        
        def Data(self):
            return b"\x00"  # Placeholder
        
        def DataLength(self):
            return 1  # Placeholder
            
        def DataAsNumpy(self):
            return np.frombuffer(self.Data(), dtype=np.uint8)


def pack_float32_array(array: np.ndarray) -> bytes:
    """Pack a float32 array into little-endian bytes.
    
    Args:
        array: NumPy array of float32 values
        
    Returns:
        Packed bytes in little-endian order
    """
    # Ensure the array is float32
    array = np.asarray(array, dtype=np.float32)
    
    # Flatten the array if it's multi-dimensional
    flat_array = array.ravel()
    
    # Pack each float32 value as little-endian bytes
    packed = bytearray()
    for value in flat_array:
        packed.extend(struct.pack('<f', value))
    
    return bytes(packed)


def unpack_float32_array(buffer: bytes, count: int, shape: Optional[Tuple[int, ...]] = None) -> np.ndarray:
    """Unpack little-endian bytes into a float32 array.
    
    Args:
        buffer: Packed bytes in little-endian order
        count: Number of float32 values to unpack
        shape: Optional shape to reshape the array to
        
    Returns:
        NumPy array of float32 values
    """
    # Unpack the bytes as float32 values
    float_size = 4  # bytes per float32
    
    # Make sure the buffer size matches the expected size
    if len(buffer) != count * float_size:
        raise ValueError(f"Buffer size {len(buffer)} doesn't match expected size {count * float_size}")
    
    # Unpack as little-endian floats
    if IS_LITTLE_ENDIAN:
        # If system is little-endian, we can use frombuffer directly
        array = np.frombuffer(buffer, dtype=np.float32)
    else:
        # If system is big-endian, unpack manually to ensure little-endian
        values = [struct.unpack('<f', buffer[i:i+float_size])[0] for i in range(0, len(buffer), float_size)]
        array = np.array(values, dtype=np.float32)
    
    # Reshape if shape is provided
    if shape is not None:
        return array.reshape(shape)
    
    return array


class StateSnapshot:
    """State snapshot container for serialization.
    
    This class represents a complete state snapshot of the ALAN system,
    including phase, momentum, and spin states.
    """
    
    def __init__(
        self, 
        theta: np.ndarray,
        p_theta: np.ndarray,
        sigma: np.ndarray,
        p_sigma: np.ndarray,
        dt_phase: float = 0.01,
        dt_spin: float = 0.00125,
    ):
        """Initialize a state snapshot.
        
        Args:
            theta: Phase angles (radians) of shape (N,)
            p_theta: Phase momenta of shape (N,)
            sigma: Spin vectors of shape (N,3)
            p_sigma: Spin momenta of shape (N,3)
            dt_phase: Phase timestep (outer loop)
            dt_spin: Spin timestep (inner loop)
        
        Raises:
            ValueError: If array shapes are inconsistent
        """
        # Validate input shapes
        n_oscillators = len(theta)
        if len(p_theta) != n_oscillators:
            raise ValueError(f"p_theta shape {len(p_theta)} != theta shape {n_oscillators}")
        
        if sigma.shape != (n_oscillators, 3):
            raise ValueError(f"sigma shape {sigma.shape} != expected {(n_oscillators, 3)}")
        
        if p_sigma.shape != (n_oscillators, 3):
            raise ValueError(f"p_sigma shape {p_sigma.shape} != expected {(n_oscillators, 3)}")
        
        # Store data
        self.theta = np.asarray(theta, dtype=np.float32)
        self.p_theta = np.asarray(p_theta, dtype=np.float32)
        self.sigma = np.asarray(sigma, dtype=np.float32)
        self.p_sigma = np.asarray(p_sigma, dtype=np.float32)
        
        # Store timestep info
        self.dt_phase = dt_phase
        self.dt_spin = dt_spin
        
        # Metadata
        self.version = 2
    
    @property
    def n_oscillators(self) -> int:
        """Get the number of oscillators in the snapshot."""
        return len(self.theta)
    
    def to_bytes(self, compress_mode: CompressMode = CompressMode.AUTO) -> bytes:
        """Serialize the snapshot to bytes using FlatBuffers.
        
        Args:
            compress_mode: Compression mode (AUTO, ALWAYS, or NEVER)
            
        Returns:
            Serialized snapshot as bytes
        """
        return to_bytes(
            self.theta,
            self.p_theta,
            self.sigma,
            self.p_sigma,
            self.dt_phase,
            self.dt_spin,
            compress_mode=compress_mode,
        )
    
    @classmethod
    def from_bytes(cls, buffer: bytes) -> 'StateSnapshot':
        """Deserialize a snapshot from bytes.
        
        Args:
            buffer: Serialized snapshot bytes
            
        Returns:
            Deserialized StateSnapshot
            
        Raises:
            ValueError: If the buffer is not a valid snapshot
        """
        # Use the module-level from_bytes function
        return from_bytes(buffer)
    
    def __repr__(self) -> str:
        """Get a string representation of the snapshot."""
        return (f"StateSnapshot(n_oscillators={self.n_oscillators}, "
                f"dt_phase={self.dt_phase}, dt_spin={self.dt_spin})")


def to_bytes(
    theta: np.ndarray,
    p_theta: np.ndarray,
    sigma: np.ndarray,
    p_sigma: np.ndarray,
    dt_phase: float = 0.01,
    dt_spin: float = 0.00125,
    compress_mode: CompressMode = CompressMode.AUTO,
) -> bytes:
    """Serialize state arrays to bytes using FlatBuffers.
    
    This implementation always packs float32 arrays in little-endian byte order
    regardless of the host system's endianness, ensuring cross-platform compatibility.
    
    Args:
        theta: Phase angles (radians) of shape (N,)
        p_theta: Phase momenta of shape (N,)
        sigma: Spin vectors of shape (N,3)
        p_sigma: Spin momenta of shape (N,3)
        dt_phase: Phase timestep (outer loop)
        dt_spin: Spin timestep (inner loop)
        compress_mode: Compression mode (AUTO, ALWAYS, or NEVER)
    
    Returns:
        Serialized state as bytes
    """
    # Create a FlatBuffers builder with an initial size
    builder = flatbuffers.Builder(0)
    
    # Pack arrays as little-endian bytes
    theta_bytes = pack_float32_array(theta)
    p_theta_bytes = pack_float32_array(p_theta)
    sigma_bytes = pack_float32_array(sigma)
    p_sigma_bytes = pack_float32_array(p_sigma)
    
    # Create byte vectors in the builder
    theta_vec = ByteVector.CreateByteVector(builder, theta_bytes)
    p_theta_vec = ByteVector.CreateByteVector(builder, p_theta_bytes)
    sigma_vec = ByteVector.CreateByteVector(builder, sigma_bytes)
    p_sigma_vec = ByteVector.CreateByteVector(builder, p_sigma_bytes)
    
    # Create the main snapshot table
    SnapshotV2.StartSnapshotV2(builder)
    SnapshotV2.AddTheta(builder, theta_vec)
    SnapshotV2.AddPTheta(builder, p_theta_vec)
    SnapshotV2.AddSigma(builder, sigma_vec)
    SnapshotV2.AddPSigma(builder, p_sigma_vec)
    SnapshotV2.AddDtPhase(builder, dt_phase)
    SnapshotV2.AddDtSpin(builder, dt_spin)
    SnapshotV2.AddEndianness(builder, LITTLE_ENDIAN)  # Always little-endian
    SnapshotV2.AddSchemaCrc32(builder, SCHEMA_CRC32)
    SnapshotV2.AddVersion(builder, VERSION)
    
    # Finish the buffer
    snapshot = SnapshotV2.EndSnapshotV2(builder)
    builder.Finish(snapshot, b"ALSN")
    
    # Get the finished buffer as bytes
    buffer = bytes(builder.Output())
    
    # Apply compression if needed
    if should_compress(buffer, compress_mode):
        try:
            buffer = compress(buffer)
            logging.debug(f"Compressed snapshot size: {len(buffer)} bytes")
        except ValueError as e:
            # If compression fails, log the error and continue with uncompressed
            logging.warning(f"Failed to compress snapshot: {e}. Using uncompressed data.")
    
    return buffer


def from_bytes(buffer: bytes) -> StateSnapshot:
    """Deserialize a state snapshot from bytes.
    
    This implementation handles both little-endian and big-endian systems
    by checking the explicit endianness flag and byte-swapping if necessary.
    It also automatically detects and decompresses compressed snapshots.
    
    Args:
        buffer: Serialized snapshot bytes
    
    Returns:
        Deserialized StateSnapshot
    
    Raises:
        ValueError: If the buffer is not a valid snapshot or has incompatible endianness
        RuntimeError: If the schema CRC32 doesn't match the expected value
    """
    # Check if the buffer is compressed
    if is_compressed(buffer):
        try:
            # Decompress the buffer
            buffer = decompress(buffer)
        except ValueError as e:
            raise ValueError(f"Failed to decompress snapshot: {e}")
    
    # Verify the buffer identifier
    if len(buffer) < 8 or buffer[4:8] != b"ALSN":
        raise ValueError("Invalid snapshot buffer (wrong identifier)")
    
    # Get the snapshot from the buffer
    snapshot = SnapshotV2.GetRootAsSnapshotV2(buffer, 0)
    
    # Verify schema version
    version = snapshot.Version()
    if version != VERSION:
        major = version >> 8
        minor = version & 0xFF
        raise ValueError(f"Incompatible schema version {major}.{minor}, expected {VERSION >> 8}.{VERSION & 0xFF}")
    
    # Verify schema CRC32
    crc32 = snapshot.SchemaCrc32()
    if crc32 != SCHEMA_CRC32:
        raise RuntimeError(f"Schema CRC32 mismatch: {crc32:08x} != {SCHEMA_CRC32:08x}")
    
    # Check endianness
    endianness = snapshot.Endianness()
    if endianness != LITTLE_ENDIAN:
        raise ValueError(f"Unsupported endianness: {endianness}")
    
    # Get timestep info
    dt_phase = snapshot.DtPhase()
    dt_spin = snapshot.DtSpin()
    
    # Get raw byte arrays
    theta_bytes = snapshot.Theta().Data()
    p_theta_bytes = snapshot.PTheta().Data()
    sigma_bytes = snapshot.Sigma().Data()
    p_sigma_bytes = snapshot.PSigma().Data()
    
    # Count the number of values in each array
    n_oscillators = len(theta_bytes) // 4  # 4 bytes per float32
    
    # Unpack the arrays
    theta = unpack_float32_array(theta_bytes, n_oscillators)
    p_theta = unpack_float32_array(p_theta_bytes, n_oscillators)
    
    # Sigma and p_sigma are flattened (N*3), reshape to (N,3)
    sigma = unpack_float32_array(sigma_bytes, n_oscillators * 3, (n_oscillators, 3))
    p_sigma = unpack_float32_array(p_sigma_bytes, n_oscillators * 3, (n_oscillators, 3))
    
    # Create and return a StateSnapshot
    return StateSnapshot(
        theta=theta,
        p_theta=p_theta,
        sigma=sigma,
        p_sigma=p_sigma,
        dt_phase=dt_phase,
        dt_spin=dt_spin,
    )

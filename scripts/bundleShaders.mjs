#!/usr/bin/env node
/**
 * bundleShaders.mjs - ES Module version of shader bundler
 * Collects all .wgsl files and generates TypeScript exports
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Paths
const SHADER_DIR = path.join(__dirname, '../frontend/lib/webgpu/shaders');
const OUTPUT_FILE = path.join(__dirname, '../frontend/lib/webgpu/generated/shaderSources.ts');

console.log('üé® Shader Bundle Generator v2.0 (ES Module)');
console.log('==========================================\n');

// Ensure output directory exists
const outputDir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
  console.log(`üìÅ Created output directory: ${outputDir}`);
}

// Read all .wgsl files
let shaderFiles = [];
try {
  shaderFiles = fs.readdirSync(SHADER_DIR)
    .filter(file => file.endsWith('.wgsl'))
    .sort();
  
  console.log(`‚ú® Found ${shaderFiles.length} shader files in ${SHADER_DIR}\n`);
} catch (err) {
  console.error(`‚ùå Error reading shader directory: ${err.message}`);
  console.error(`   Path: ${SHADER_DIR}`);
  process.exit(1);
}

// Generate the TypeScript file
const timestamp = new Date().toISOString();
let output = `/**
 * Auto-generated shader bundle
 * Generated: ${timestamp}
 * Total shaders: ${shaderFiles.length}
 * 
 * DO NOT EDIT - This file is auto-generated by scripts/bundleShaders.mjs
 */

`;

const validShaders = [];
const shaderInfo = [];

for (const file of shaderFiles) {
  // Convert filename to valid TypeScript variable name
  const varName = file
    .replace('.wgsl', '_wgsl')
    .replace(/[^a-zA-Z0-9_]/g, '_')
    .replace(/^(\d)/, '_$1'); // Ensure it doesn't start with a number
  
  const filepath = path.join(SHADER_DIR, file);
  
  try {
    const content = fs.readFileSync(filepath, 'utf8');
    
    // Extract shader info from comments if available
    const purposeMatch = content.match(/\/\*\*?\s*@purpose\s+(.+?)\s*\*\//);
    const purpose = purposeMatch ? purposeMatch[1] : 'No description';
    
    // Use JSON.stringify for proper escaping
    output += `// Shader: ${file}\n`;
    output += `// Purpose: ${purpose}\n`;
    output += `export const ${varName} = ${JSON.stringify(content)};\n\n`;
    
    validShaders.push(varName);
    shaderInfo.push({ name: file, variable: varName, purpose });
    console.log(`  ‚úÖ ${file} -> ${varName}`);
    
  } catch (err) {
    console.error(`  ‚ùå ${file}: ${err.message}`);
    // Still export empty string so imports don't break
    output += `// ERROR loading ${file}: ${err.message}\n`;
    output += `export const ${varName} = '';\n\n`;
  }
}

// Add typed shader sources object
output += `/**
 * Shader sources object with all loaded shaders
 */
export const shaderSources = {
${validShaders.map(name => `  ${name}`).join(',\n')}
} as const;

/**
 * Shader metadata for runtime introspection
 */
export const shaderMetadata = ${JSON.stringify(shaderInfo, null, 2)};

/**
 * Get shader source by name
 */
export function getShader(name: keyof typeof shaderSources): string {
  return shaderSources[name];
}

// Default export
export default shaderSources;
`;

// Write the file
try {
  fs.writeFileSync(OUTPUT_FILE, output);
  
  console.log(`\n‚úÖ Successfully generated shader bundle!`);
  console.log(`   Output: ${OUTPUT_FILE}`);
  console.log(`   Size: ${Math.round(output.length / 1024)} KB`);
  console.log(`   Valid shaders: ${validShaders.length}/${shaderFiles.length}`);
  
  // Generate index file for easy imports
  const indexPath = path.join(outputDir, 'index.ts');
  const indexContent = `// Shader bundle index
export * from './shaderSources';
`;
  fs.writeFileSync(indexPath, indexContent);
  console.log(`   Index: ${indexPath}`);
  
} catch (err) {
  console.error(`\n‚ùå Failed to write output file: ${err.message}`);
  process.exit(1);
}

console.log('\nüéâ Shader bundling complete!');

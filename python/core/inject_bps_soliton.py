# inject_bps_soliton.py\n# ------------------------------------------------------------------\n# Replaces classic 'inject_as_bright_solitons' with BPS-safe version\n# Creates phase-aligned, charge-tagged solitons in oscillator lattice\n# PRODUCTION READY - Full BPS integration with centralized config!\n# ------------------------------------------------------------------\n\nimport numpy as np\nimport logging\nimport time\nfrom typing import Optional, List, Dict, Any, Union\n\n# 🌟 EPIC BPS CONFIG INTEGRATION 🌟\ntry:\n    from .bps_config import (\n        # Feature flags\n        ENABLE_BPS_PHASE_LOCKING, ENABLE_BPS_CHARGE_TRACKING, ENABLE_BPS_SAFETY_CHECKS,\n        STRICT_BPS_MODE, ENABLE_DETAILED_LOGGING,\n        \n        # Phase parameters\n        BPS_PHASE_LOCK_GAIN, PHASE_COHERENCE_THRESHOLD,\n        \n        # Charge parameters\n        ALLOWED_Q_VALUES, CHARGE_QUANTIZATION_THRESHOLD,\n        \n        # Soliton parameters\n        DEFAULT_SOLITON_WIDTH, DEFAULT_SOLITON_AMPLITUDE,\n        \n        # Performance\n        PERFORMANCE_PROFILING_ENABLED, SLOW_OPERATION_THRESHOLD\n    )\n    BPS_CONFIG_AVAILABLE = True\n    logger = logging.getLogger(__name__)\n    logger.info(\"🚀 BPS Soliton Injector using centralized configuration!\")\n    \nexcept ImportError:\n    logger = logging.getLogger(__name__)\n    logger.warning(\"⚠️ BPS config unavailable - using fallback constants\")\n    \n    # Fallback constants\n    ENABLE_BPS_PHASE_LOCKING = True\n    ENABLE_BPS_CHARGE_TRACKING = True\n    ENABLE_BPS_SAFETY_CHECKS = True\n    STRICT_BPS_MODE = False\n    ENABLE_DETAILED_LOGGING = True\n    \n    BPS_PHASE_LOCK_GAIN = 0.5\n    PHASE_COHERENCE_THRESHOLD = 0.1\n    ALLOWED_Q_VALUES = {-2, -1, 0, 1, 2}\n    CHARGE_QUANTIZATION_THRESHOLD = 0.5\n    DEFAULT_SOLITON_WIDTH = 40.0\n    DEFAULT_SOLITON_AMPLITUDE = 1.0\n    \n    PERFORMANCE_PROFILING_ENABLED = False\n    SLOW_OPERATION_THRESHOLD = 1.0\n    \n    BPS_CONFIG_AVAILABLE = False\n\n# Import BPS components with graceful fallbacks\ntry:\n    from .bps_oscillator import BPSOscillator\n    BPS_OSCILLATOR_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\"BPS oscillator not available - using fallback\")\n    BPS_OSCILLATOR_AVAILABLE = False\n    \n    # Minimal fallback oscillator\n    class BPSOscillator:\n        def __init__(self, index, theta=0.0, omega=0.0):\n            self.index = index\n            self.theta = theta\n            self.omega = omega\n            self.charge = 0\n            \n        def assign_bps_charge(self, charge):\n            self.charge = int(np.sign(charge)) if abs(charge) > 0.5 else 0\n            \n        def lock_to_phase(self, target_phase, gain=0.5):\n            delta = target_phase - self.theta\n            self.theta += gain * np.sin(delta)\n            return abs(delta) < 0.1\n\ntry:\n    from .soliton_memory_integration import EnhancedSolitonMemory\n    MEMORY_INTEGRATION_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\"Enhanced soliton memory not available - using fallback\")\n    MEMORY_INTEGRATION_AVAILABLE = False\n    \n    # Minimal fallback memory\n    class EnhancedSolitonMemory:\n        def __init__(self):\n            self.solitons = {}\n            self.next_id = 0\n            \n        def register_bps_soliton(self, oscillators, charge):\n            soliton_id = f\"soliton_{self.next_id}\"\n            self.solitons[soliton_id] = {'oscillators': oscillators, 'charge': charge}\n            self.next_id += 1\n            return soliton_id\n\n# ⚡ CORE BPS SOLITON INJECTION FUNCTIONS ⚡\n\ndef phase_gradient_profile(center: int, width: float, charge: int, length: int) -> np.ndarray:\n    \"\"\"\n    Generate BPS-compliant phase gradient profile for soliton injection! 🌊\n    \n    Args:\n        center: Center position of soliton\n        width: Width parameter (controls soliton size)\n        charge: Topological charge (+1 for bright, -1 for dark)\n        length: Total length of the profile\n        \n    Returns:\n        Phase profile array with topological winding\n    \"\"\"\n    try:\n        # Validate inputs with BPS config\n        if ENABLE_BPS_SAFETY_CHECKS:\n            if charge not in ALLOWED_Q_VALUES:\n                if STRICT_BPS_MODE:\n                    raise ValueError(f\"Invalid charge {charge} not in {ALLOWED_Q_VALUES}\")\n                else:\n                    logger.warning(f\"Charge {charge} clamped to allowed range\")\n                    charge = max(-2, min(2, charge))\n        \n        # Create spatial coordinate array\n        x = np.arange(length, dtype=float)\n        x_centered = x - center\n        \n        # Generate topological phase profile\n        if charge > 0:\n            # Bright soliton: phase winds around center\n            profile = charge * np.arctan2(x_centered, width)\n        elif charge < 0:\n            # Dark soliton: inverted phase profile\n            profile = charge * np.arctan2(width, x_centered)\n        else:\n            # Neutral: flat phase\n            profile = np.zeros(length)\n        \n        # Normalize to [0, 2π]\n        profile = (profile + 2*np.pi) % (2*np.pi)\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"🌊 Generated phase profile: center={center}, width={width:.1f}, \"\n                        f\"charge={charge}, length={length}\")\n        \n        return profile\n        \n    except Exception as e:\n        logger.error(f\"Failed to generate phase profile: {e}\")\n        if STRICT_BPS_MODE:\n            raise\n        # Emergency fallback: linear phase\n        return np.linspace(0, 2*np.pi, length)\n\ndef entrain_oscillators_to_profile(oscillators: List[BPSOscillator], \n                                  phase_profile: np.ndarray,\n                                  gain: Optional[float] = None,\n                                  max_iterations: int = 100) -> Dict[str, Any]:\n    \"\"\"\n    Entrain oscillators to follow a BPS phase profile! 🔄⚡\n    \n    Args:\n        oscillators: List of BPS oscillators to entrain\n        phase_profile: Target phase profile\n        gain: Phase lock gain (default from config)\n        max_iterations: Maximum entrainment iterations\n        \n    Returns:\n        Entrainment metrics and status\n    \"\"\"\n    if not ENABLE_BPS_PHASE_LOCKING:\n        logger.warning(\"Phase locking disabled - skipping entrainment\")\n        return {'status': 'disabled', 'locked_count': 0}\n    \n    start_time = time.time() if PERFORMANCE_PROFILING_ENABLED else 0.0\n    \n    if gain is None:\n        gain = BPS_PHASE_LOCK_GAIN\n    \n    try:\n        locked_count = 0\n        total_oscillators = len(oscillators)\n        \n        for iteration in range(max_iterations):\n            newly_locked = 0\n            \n            for i, osc in enumerate(oscillators):\n                if i < len(phase_profile):\n                    target_phase = phase_profile[i]\n                    \n                    # Apply phase locking\n                    if hasattr(osc, 'lock_to_phase'):\n                        lock_achieved = osc.lock_to_phase(target_phase, gain)\n                        if lock_achieved:\n                            newly_locked += 1\n                    else:\n                        # Fallback direct assignment\n                        delta = target_phase - osc.theta\n                        correction = gain * np.sin(delta)\n                        osc.theta += correction\n                        \n                        if abs(delta) < PHASE_COHERENCE_THRESHOLD:\n                            newly_locked += 1\n            \n            locked_count = newly_locked\n            \n            # Check convergence\n            convergence_rate = locked_count / total_oscillators\n            if convergence_rate > 0.95:\n                if ENABLE_DETAILED_LOGGING:\n                    logger.debug(f\"🔄 Entrainment converged after {iteration+1} iterations: \"\n                                f\"{convergence_rate:.1%} locked\")\n                break\n        \n        # Performance tracking\n        metrics = {\n            'status': 'converged' if convergence_rate > 0.95 else 'partial',\n            'locked_count': locked_count,\n            'total_count': total_oscillators,\n            'convergence_rate': convergence_rate,\n            'iterations': iteration + 1\n        }\n        \n        if PERFORMANCE_PROFILING_ENABLED:\n            entrainment_time = time.time() - start_time\n            metrics['entrainment_time'] = entrainment_time\n            \n            if entrainment_time > SLOW_OPERATION_THRESHOLD:\n                logger.warning(f\"Slow entrainment operation: {entrainment_time:.3f}s\")\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.info(f\"🔄 Entrainment complete: {metrics['convergence_rate']:.1%} locked \"\n                       f\"in {metrics['iterations']} iterations\")\n        \n        return metrics\n        \n    except Exception as e:\n        logger.error(f\"Entrainment failed: {e}\")\n        if STRICT_BPS_MODE:\n            raise\n        return {'status': 'error', 'error': str(e), 'locked_count': 0}\n\ndef inject_bps_soliton(memory: EnhancedSolitonMemory, \n                      lattice, \n                      charge: int = 1, \n                      center: Optional[int] = None, \n                      width: Optional[float] = None,\n                      amplitude: Optional[float] = None) -> str:\n    \"\"\"\n    🚀 THE MAIN EVENT: Inject a phase-aligned BPS soliton into the lattice! ⚡\n    \n    Automatically registers soliton in memory and phase-locks oscillators.\n    This is the PRODUCTION-READY replacement for legacy injection logic!\n    \n    Args:\n        memory: EnhancedSolitonMemory object for registration\n        lattice: Lattice system (only shape is used)\n        charge: Topological charge (+1 bright, -1 dark, 0 neutral)\n        center: Center position (defaults to midpoint)\n        width: Profile width (defaults to config value)\n        amplitude: Soliton amplitude (defaults to config value)\n    \n    Returns:\n        soliton_id: ID of the registered BPS soliton\n        \n    Raises:\n        ValueError: If charge is invalid in strict mode\n        RuntimeError: If injection fails in strict mode\n    \"\"\"\n    start_time = time.time() if PERFORMANCE_PROFILING_ENABLED else 0.0\n    \n    try:\n        # Extract lattice dimensions\n        if hasattr(lattice, 'shape'):\n            length = lattice.shape[0]\n        elif hasattr(lattice, '__len__'):\n            length = len(lattice)\n        else:\n            length = 100  # Fallback default\n        \n        # Set defaults from config\n        if center is None:\n            center = length // 2\n        if width is None:\n            width = DEFAULT_SOLITON_WIDTH\n        if amplitude is None:\n            amplitude = DEFAULT_SOLITON_AMPLITUDE\n        \n        # Validate charge\n        if ENABLE_BPS_CHARGE_TRACKING and ENABLE_BPS_SAFETY_CHECKS:\n            if charge not in ALLOWED_Q_VALUES:\n                if STRICT_BPS_MODE:\n                    raise ValueError(f\"Invalid charge {charge} not in {ALLOWED_Q_VALUES}\")\n                else:\n                    logger.warning(f\"Charge {charge} clamped to allowed range\")\n                    charge = max(-2, min(2, charge))\n        \n        logger.info(f\"🚀 Injecting BPS soliton: Q={charge}, center={center}, width={width:.1f}\")\n        \n        # Create oscillator array\n        oscillators = []\n        for i in range(length):\n            osc = BPSOscillator(i, theta=0.0, omega=0.0)\n            osc.amplitude = amplitude\n            oscillators.append(osc)\n        \n        # Generate BPS phase profile\n        profile = phase_gradient_profile(\n            center=center, \n            width=width, \n            charge=charge, \n            length=length\n        )\n        \n        # Entrain oscillators to profile\n        entrainment_metrics = entrain_oscillators_to_profile(oscillators, profile)\n        \n        if entrainment_metrics['status'] == 'error':\n            if STRICT_BPS_MODE:\n                raise RuntimeError(f\"Entrainment failed: {entrainment_metrics.get('error')}\")\n            else:\n                logger.warning(\"Entrainment failed - proceeding with partial lock\")\n        \n        # Assign BPS charges to oscillators\n        if ENABLE_BPS_CHARGE_TRACKING:\n            for osc in oscillators:\n                osc.assign_bps_charge(charge)\n        \n        # Register soliton in memory\n        try:\n            soliton_id = memory.register_bps_soliton(oscillators, charge)\n        except Exception as e:\n            if STRICT_BPS_MODE:\n                raise RuntimeError(f\"Memory registration failed: {e}\")\n            else:\n                logger.warning(f\"Memory registration failed: {e}\")\n                # Generate fallback ID\n                soliton_id = f\"fallback_soliton_{int(time.time())}\"\n        \n        # Performance tracking\n        if PERFORMANCE_PROFILING_ENABLED:\n            injection_time = time.time() - start_time\n            \n            if injection_time > SLOW_OPERATION_THRESHOLD:\n                logger.warning(f\"Slow soliton injection: {injection_time:.3f}s\")\n            \n            logger.debug(f\"⚡ Injection performance: {injection_time*1000:.1f}ms, \"\n                        f\"entrainment: {entrainment_metrics.get('iterations', 0)} iterations\")\n        \n        # Success logging\n        convergence = entrainment_metrics.get('convergence_rate', 0.0)\n        logger.info(f\"✅ BPS soliton '{soliton_id}' injected successfully! \"\n                   f\"Q={charge}, convergence={convergence:.1%}\")\n        \n        return soliton_id\n        \n    except Exception as e:\n        logger.error(f\"BPS soliton injection failed: {e}\")\n        if STRICT_BPS_MODE:\n            raise\n        # Return error indicator\n        return f\"error_soliton_{int(time.time())}\"\n\n# 🎯 UTILITY FUNCTIONS FOR ADVANCED SOLITON MANAGEMENT\n\ndef inject_soliton_pair(memory: EnhancedSolitonMemory,\n                       lattice,\n                       separation: int = 100,\n                       charges: tuple = (1, -1)) -> tuple:\n    \"\"\"\n    Inject a bright-dark soliton pair for charge neutrality! ⚡⚫\n    \n    Args:\n        memory: Memory system\n        lattice: Target lattice\n        separation: Distance between solitons\n        charges: Charge pair (default: bright +1, dark -1)\n        \n    Returns:\n        Tuple of (bright_id, dark_id)\n    \"\"\"\n    try:\n        length = lattice.shape[0] if hasattr(lattice, 'shape') else len(lattice)\n        center = length // 2\n        \n        # Inject bright soliton\n        bright_center = center - separation // 2\n        bright_id = inject_bps_soliton(\n            memory, lattice, \n            charge=charges[0], \n            center=bright_center\n        )\n        \n        # Inject dark soliton\n        dark_center = center + separation // 2\n        dark_id = inject_bps_soliton(\n            memory, lattice,\n            charge=charges[1],\n            center=dark_center\n        )\n        \n        logger.info(f\"⚡⚫ Soliton pair injected: bright='{bright_id}', dark='{dark_id}'\")\n        return (bright_id, dark_id)\n        \n    except Exception as e:\n        logger.error(f\"Soliton pair injection failed: {e}\")\n        if STRICT_BPS_MODE:\n            raise\n        return (\"error_bright\", \"error_dark\")\n\ndef validate_soliton_injection(oscillators: List[BPSOscillator], \n                             expected_charge: int) -> Dict[str, Any]:\n    \"\"\"\n    Validate successful BPS soliton injection! 🔍\n    \n    Args:\n        oscillators: List of oscillators to validate\n        expected_charge: Expected total topological charge\n        \n    Returns:\n        Validation metrics and status\n    \"\"\"\n    try:\n        total_charge = sum(osc.charge for osc in oscillators if hasattr(osc, 'charge'))\n        phase_coherence = np.mean([abs(np.exp(1j * osc.theta)) for osc in oscillators])\n        \n        # Check charge conservation\n        charge_error = abs(total_charge - expected_charge)\n        charge_conserved = charge_error < CHARGE_QUANTIZATION_THRESHOLD\n        \n        # Check phase alignment\n        well_aligned = phase_coherence > 0.8\n        \n        validation = {\n            'status': 'valid' if (charge_conserved and well_aligned) else 'issues',\n            'total_charge': total_charge,\n            'expected_charge': expected_charge,\n            'charge_error': charge_error,\n            'charge_conserved': charge_conserved,\n            'phase_coherence': phase_coherence,\n            'well_aligned': well_aligned,\n            'oscillator_count': len(oscillators)\n        }\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"🔍 Soliton validation: {validation['status']}, \"\n                        f\"Q={total_charge}/{expected_charge}, coherence={phase_coherence:.3f}\")\n        \n        return validation\n        \n    except Exception as e:\n        logger.error(f\"Soliton validation failed: {e}\")\n        return {'status': 'error', 'error': str(e)}\n\n# Export all the epic functions!\n__all__ = [\n    'inject_bps_soliton',\n    'phase_gradient_profile', \n    'entrain_oscillators_to_profile',\n    'inject_soliton_pair',\n    'validate_soliton_injection',\n    'BPS_CONFIG_AVAILABLE'\n]\n\nif __name__ == \"__main__\":\n    # 🎪 DEMONSTRATION MODE!\n    logger.info(\"🚀 BPS Soliton Injector System ACTIVATED!\")\n    logger.info(f\"⚡ Config: {'CENTRALIZED' if BPS_CONFIG_AVAILABLE else 'FALLBACK'}\")\n    \n    import sys\n    if '--demo' in sys.argv:\n        logger.info(\"🎪 Running demo injection...\")\n        \n        # Create demo components\n        class DemoLattice:\n            def __init__(self, size=200):\n                self.shape = (size,)\n                self.psi = np.zeros(size, dtype=complex)\n        \n        # Demo injection\n        lattice = DemoLattice(200)\n        memory = EnhancedSolitonMemory()\n        \n        # Inject bright soliton\n        bright_id = inject_bps_soliton(memory, lattice, charge=1, center=75)\n        logger.info(f\"✅ Bright soliton injected: {bright_id}\")\n        \n        # Inject dark soliton\n        dark_id = inject_bps_soliton(memory, lattice, charge=-1, center=125)\n        logger.info(f\"✅ Dark soliton injected: {dark_id}\")\n        \n        # Inject neutral pair\n        pair_ids = inject_soliton_pair(memory, lattice, separation=80)\n        logger.info(f\"✅ Soliton pair injected: {pair_ids}\")\n        \n        logger.info(f\"🎪 Demo complete! Total solitons in memory: {len(memory.solitons)}\")\n    \n    logger.info(\"🎯 BPS Soliton Injector ready for PRODUCTION use!\")\n"
# bps_oscillator.py\n# -------------------------------------------------\n# BPS-aware oscillator class: supports topological charge,\n# phase-locking to soliton profiles, and symbolic identity\n# PRODUCTION VERSION - Fully integrated with centralized BPS config\n# -------------------------------------------------\n\nimport numpy as np\nimport logging\nimport time\nfrom typing import Any, Dict, List, Optional, Tuple, Union\n\n# Import centralized BPS configuration\ntry:\n    from .bps_config import (\n        # Feature flags\n        ENABLE_BPS_PHASE_LOCKING, ENABLE_BPS_CHARGE_TRACKING, ENABLE_BPS_SAFETY_CHECKS,\n        STRICT_BPS_MODE, ENABLE_DETAILED_LOGGING,\n        \n        # Phase locking parameters\n        BPS_PHASE_LOCK_GAIN, KURAMOTO_COUPLING_STRENGTH, MAX_PHASE_CORRECTION,\n        PHASE_COHERENCE_THRESHOLD,\n        \n        # Charge parameters\n        ALLOWED_Q_VALUES, MAX_ALLOWED_CHARGE_MAGNITUDE, CHARGE_QUANTIZATION_THRESHOLD,\n        \n        # Tolerances\n        CHARGE_CONSERVATION_TOLERANCE, BPS_BOUND_VIOLATION_TOLERANCE,\n        \n        # Symbolic tags\n        SOLITON_TAGS, STATE_TAGS,\n        \n        # Performance\n        SLOW_OPERATION_THRESHOLD, PERFORMANCE_PROFILING_ENABLED\n    )\n    BPS_CONFIG_AVAILABLE = True\n    logger = logging.getLogger(\"BPSOscillator\")\n    logger.info(\"BPS oscillator using centralized configuration\")\n    \nexcept ImportError:\n    logger = logging.getLogger(\"BPSOscillator\")\n    logger.warning(\"BPS config unavailable - using fallback constants\")\n    \n    # Feature flags (conservative defaults)\n    ENABLE_BPS_PHASE_LOCKING = True\n    ENABLE_BPS_CHARGE_TRACKING = True\n    ENABLE_BPS_SAFETY_CHECKS = True\n    STRICT_BPS_MODE = False\n    ENABLE_DETAILED_LOGGING = True\n    \n    # Phase locking parameters\n    BPS_PHASE_LOCK_GAIN = 0.5\n    KURAMOTO_COUPLING_STRENGTH = 0.3\n    MAX_PHASE_CORRECTION = 0.5\n    PHASE_COHERENCE_THRESHOLD = 0.1\n    \n    # Charge parameters\n    ALLOWED_Q_VALUES = {-2, -1, 0, 1, 2}\n    MAX_ALLOWED_CHARGE_MAGNITUDE = 2\n    CHARGE_QUANTIZATION_THRESHOLD = 0.5\n    \n    # Tolerances\n    CHARGE_CONSERVATION_TOLERANCE = 1e-10\n    BPS_BOUND_VIOLATION_TOLERANCE = 1e-6\n    \n    # Tags\n    SOLITON_TAGS = {'bright_bps': \"Bright BPS\", 'dark_bps': \"Dark BPS\"}\n    STATE_TAGS = {'phase_locked': \"Phase Locked\"}\n    \n    # Performance\n    SLOW_OPERATION_THRESHOLD = 1.0\n    PERFORMANCE_PROFILING_ENABLED = False\n    \n    BPS_CONFIG_AVAILABLE = False\n\nclass BPSOscillator:\n    \"\"\"\n    Extension of base oscillator with BPS tagging, phase tracking,\n    and topological charge integration.\n    \n    Production-grade oscillator with centralized BPS configuration,\n    feature flag controls, and comprehensive error handling.\n    \"\"\"\n    \n    def __init__(self, index: int, theta: float = 0.0, omega: float = 0.0,\n                 enable_bps_features: Optional[bool] = None):\n        \"\"\"\n        Initialize BPS-aware oscillator with config-driven behavior.\n        \n        Args:\n            index: Oscillator index/ID\n            theta: Initial phase\n            omega: Natural frequency  \n            enable_bps_features: Override BPS feature activation\n        \"\"\"\n        self.index = index\n        self.theta = theta        # Phase\n        self.omega = omega        # Natural frequency\n        self.charge = 0           # Default: not a soliton\n        self.phase_locked = False\n        self.symbolic_tag = None\n        \n        # BPS feature control\n        if enable_bps_features is None:\n            self.bps_features_enabled = BPS_CONFIG_AVAILABLE\n        else:\n            self.bps_features_enabled = enable_bps_features\n            \n        # Configuration-driven initialization\n        self.phase_lock_gain = BPS_PHASE_LOCK_GAIN\n        self.coupling_strength = KURAMOTO_COUPLING_STRENGTH\n        self.max_phase_correction = MAX_PHASE_CORRECTION\n        \n        # Performance tracking\n        self.operation_count = 0\n        self.phase_lock_count = 0\n        self.last_operation_time = 0.0\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"BPS oscillator {index} initialized: θ={theta:.3f}, ω={omega:.3f}, \"\n                        f\"BPS={'ON' if self.bps_features_enabled else 'OFF'}\")\n\n    def assign_bps_charge(self, q: int):\n        \"\"\"\n        Assigns topological charge to oscillator with config validation.\n        \n        Args:\n            q: Raw charge value (will be quantized to ±1)\n        \"\"\"\n        # Feature flag check\n        if not ENABLE_BPS_CHARGE_TRACKING:\n            if ENABLE_DETAILED_LOGGING:\n                logger.debug(f\"Charge tracking disabled - ignoring charge assignment for osc {self.index}\")\n            return\n            \n        # Quantize charge using config threshold\n        if abs(q) > CHARGE_QUANTIZATION_THRESHOLD:\n            quantized_charge = int(np.sign(q))\n        else:\n            quantized_charge = 0\n            \n        # Validate against allowed values\n        if ENABLE_BPS_SAFETY_CHECKS and quantized_charge not in ALLOWED_Q_VALUES:\n            if STRICT_BPS_MODE:\n                raise ValueError(f\"Invalid charge {quantized_charge} not in {ALLOWED_Q_VALUES}\")\n            else:\n                logger.warning(f\"Charge {quantized_charge} not in allowed values {ALLOWED_Q_VALUES}\")\n                # Clamp to allowed range\n                quantized_charge = max(-MAX_ALLOWED_CHARGE_MAGNITUDE, \n                                     min(MAX_ALLOWED_CHARGE_MAGNITUDE, quantized_charge))\n        \n        old_charge = self.charge\n        self.charge = quantized_charge\n        \n        # Update symbolic tag based on charge\n        if quantized_charge > 0:\n            self.symbolic_tag = SOLITON_TAGS.get('bright_bps', 'Positive Soliton')\n        elif quantized_charge < 0:\n            self.symbolic_tag = SOLITON_TAGS.get('dark_bps', 'Negative Soliton')\n        else:\n            self.symbolic_tag = None\n            \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"[BPS-Osc] Oscillator {self.index} charge: {old_charge} → {self.charge} \"\n                        f\"(tag: {self.symbolic_tag})\")\n\n    def set_symbolic_id(self, label: str):\n        \"\"\"\n        Attach human-readable label to oscillator.\n        \n        Args:\n            label: Symbolic identifier for debugging/UI\n        \"\"\"\n        self.symbolic_tag = label\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"[BPS-Osc] Oscillator {self.index} tagged as '{label}'\")\n\n    def lock_to_phase(self, target_phase: float, gain: Optional[float] = None):\n        \"\"\"\n        Applies soft phase-locking to a BPS soliton-defined target phase.\n        This nudges the oscillator toward stable solitonic alignment.\n        \n        Args:\n            target_phase: Target phase for locking\n            gain: Phase lock strength (default from config)\n        \"\"\"\n        # Feature flag check\n        if not ENABLE_BPS_PHASE_LOCKING:\n            if ENABLE_DETAILED_LOGGING:\n                logger.debug(f\"Phase locking disabled - ignoring lock request for osc {self.index}\")\n            return\n            \n        # Use config default if not specified\n        if gain is None:\n            gain = self.phase_lock_gain\n            \n        # Compute phase difference\n        delta = target_phase - self.theta\n        \n        # Normalize delta to [-π, π]\n        while delta > np.pi:\n            delta -= 2 * np.pi\n        while delta < -np.pi:\n            delta += 2 * np.pi\n            \n        # Apply correction with config-driven limits\n        correction = gain * np.sin(delta)\n        \n        # Limit correction magnitude using config\n        if abs(correction) > self.max_phase_correction:\n            correction = np.sign(correction) * self.max_phase_correction\n            if ENABLE_DETAILED_LOGGING:\n                logger.debug(f\"Phase correction limited to {self.max_phase_correction}\")\n        \n        old_theta = self.theta\n        self.theta += correction\n        \n        # Check if phase lock achieved\n        if abs(delta) < PHASE_COHERENCE_THRESHOLD:\n            if not self.phase_locked:\n                self.phase_locked = True\n                if ENABLE_DETAILED_LOGGING:\n                    logger.debug(f\"[BPS-Osc] Oscillator {self.index} achieved phase lock\")\n        else:\n            self.phase_locked = False\n            \n        self.phase_lock_count += 1\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"[BPS-Osc] Phase lock {self.index}: θ {old_theta:.3f}→{self.theta:.3f} \"\n                        f\"(Δ={delta:.3f}, correction={correction:.3f})\")\n\n    def step(self, dt: float = 1.0, external_coupling: float = 0.0):\n        \"\"\"\n        Advance oscillator by one time step with config-driven behavior.\n        \n        Args:\n            dt: Time step size\n            external_coupling: External coupling term (e.g., from other oscillators)\n        \"\"\"\n        start_time = time.time() if PERFORMANCE_PROFILING_ENABLED else 0.0\n        \n        # Natural evolution (unless strictly phase-locked)\n        if not self.phase_locked:\n            self.theta += self.omega * dt\n        \n        # Add external coupling with config-driven strength\n        if external_coupling != 0.0:\n            coupling_effect = self.coupling_strength * external_coupling * dt\n            self.theta += coupling_effect\n            \n            if ENABLE_DETAILED_LOGGING and abs(coupling_effect) > PHASE_COHERENCE_THRESHOLD:\n                logger.debug(f\"[BPS-Osc] Oscillator {self.index} coupling effect: {coupling_effect:.3f}\")\n        \n        # Normalize phase to [0, 2π]\n        self.theta = self.theta % (2 * np.pi)\n        \n        # Update performance tracking\n        self.operation_count += 1\n        \n        if PERFORMANCE_PROFILING_ENABLED:\n            operation_time = time.time() - start_time\n            self.last_operation_time = operation_time\n            \n            # Warn about slow operations\n            if operation_time > SLOW_OPERATION_THRESHOLD / 1000:  # Convert to milliseconds\n                logger.warning(f\"[BPS-Osc] Slow operation on oscillator {self.index}: {operation_time*1000:.2f}ms\")\n            \n            # Periodic performance summary\n            if self.operation_count % 10000 == 0:\n                logger.debug(f\"[BPS-Osc] Oscillator {self.index} completed {self.operation_count} operations\")\n\n    def kuramoto_coupling(self, other_oscillators: List['BPSOscillator'], \n                         coupling_strength: Optional[float] = None) -> float:\n        \"\"\"\n        Compute Kuramoto coupling term from neighboring oscillators.\n        \n        Args:\n            other_oscillators: List of coupled oscillators\n            coupling_strength: Override coupling strength\n            \n        Returns:\n            Coupling term for use in step()\n        \"\"\"\n        if not other_oscillators:\n            return 0.0\n            \n        if coupling_strength is None:\n            coupling_strength = self.coupling_strength\n            \n        # Standard Kuramoto coupling: K * Σ sin(θⱼ - θᵢ)\n        coupling_sum = 0.0\n        for other in other_oscillators:\n            if other.index != self.index:  # Don't couple to self\n                phase_diff = other.theta - self.theta\n                coupling_sum += np.sin(phase_diff)\n                \n        # Normalize by number of neighbors\n        if len(other_oscillators) > 1:\n            coupling_sum /= (len(other_oscillators) - 1)\n            \n        return coupling_strength * coupling_sum\n\n    def get_phase_coherence(self, other_oscillators: List['BPSOscillator']) -> float:\n        \"\"\"\n        Compute phase coherence with other oscillators.\n        \n        Args:\n            other_oscillators: List of oscillators to check coherence with\n            \n        Returns:\n            Phase coherence measure [0, 1]\n        \"\"\"\n        if not other_oscillators:\n            return 1.0\n            \n        # Compute complex order parameter\n        exp_sum = sum(np.exp(1j * osc.theta) for osc in other_oscillators + [self])\n        coherence = abs(exp_sum) / len(other_oscillators + 1)\n        \n        return coherence\n\n    def snapshot(self) -> Dict[str, Any]:\n        \"\"\"Return comprehensive state snapshot for introspection or export.\"\"\"\n        snapshot = {\n            \"index\": self.index,\n            \"theta\": self.theta,\n            \"omega\": self.omega,\n            \"charge\": self.charge,\n            \"symbol\": self.symbolic_tag,\n            \"phase_locked\": self.phase_locked,\n            \"bps_features_enabled\": self.bps_features_enabled,\n            \"operation_count\": self.operation_count,\n            \"phase_lock_count\": self.phase_lock_count\n        }\n        \n        # Add performance data if available\n        if PERFORMANCE_PROFILING_ENABLED:\n            snapshot.update({\n                \"last_operation_time\": self.last_operation_time,\n                \"avg_operations_per_lock\": (self.phase_lock_count / max(self.operation_count, 1))\n            })\n            \n        return snapshot\n\n    def reset(self, theta: Optional[float] = None, omega: Optional[float] = None,\n             preserve_charge: bool = True):\n        \"\"\"\n        Reset oscillator state with optional parameter updates.\n        \n        Args:\n            theta: New phase (None to keep current)\n            omega: New frequency (None to keep current)\n            preserve_charge: Whether to keep current topological charge\n        \"\"\"\n        if theta is not None:\n            self.theta = theta\n        if omega is not None:\n            self.omega = omega\n            \n        # Reset state\n        self.phase_locked = False\n        \n        if not preserve_charge:\n            self.charge = 0\n            self.symbolic_tag = None\n            \n        # Reset performance counters\n        self.operation_count = 0\n        self.phase_lock_count = 0\n        self.last_operation_time = 0.0\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"[BPS-Osc] Oscillator {self.index} reset: θ={self.theta:.3f}, ω={self.omega:.3f}\")\n\n    def __repr__(self):\n        status = \"🔒\" if self.phase_locked else \"~\"\n        charge_symbol = {-1: \"⊖\", 0: \"○\", 1: \"⊕\"}.get(self.charge, str(self.charge))\n        return f\"<BPSOscillator #{self.index} θ={self.theta:.2f} ω={self.omega:.2f} Q={charge_symbol} {status}>\"\n\n# ═══════════════════════════════════════════════════════════════════════════════\n# Utility Functions\n# ═══════════════════════════════════════════════════════════════════════════════\n\ndef create_bps_oscillator_network(count: int, omega_range: Tuple[float, float] = (0.5, 1.5),\n                                  charge_density: float = 0.1) -> List[BPSOscillator]:\n    \"\"\"\n    Create a network of BPS oscillators with random parameters.\n    \n    Args:\n        count: Number of oscillators\n        omega_range: Range for random frequencies\n        charge_density: Fraction of oscillators with non-zero charge\n        \n    Returns:\n        List of configured BPS oscillators\n    \"\"\"\n    oscillators = []\n    \n    for i in range(count):\n        # Random initial conditions\n        theta = np.random.uniform(0, 2 * np.pi)\n        omega = np.random.uniform(*omega_range)\n        \n        osc = BPSOscillator(i, theta, omega)\n        \n        # Assign charges to some oscillators\n        if np.random.random() < charge_density:\n            charge = np.random.choice([-1, 1])\n            osc.assign_bps_charge(charge)\n            \n        oscillators.append(osc)\n        \n    logger.info(f\"Created BPS oscillator network: {count} oscillators, \"\n               f\"{sum(1 for o in oscillators if o.charge != 0)} charged\")\n    \n    return oscillators\n\ndef validate_bps_oscillator() -> Dict[str, Any]:\n    \"\"\"\n    Validate BPS oscillator functionality and configuration.\n    \n    Returns:\n        Dictionary with validation results\n    \"\"\"\n    validation = {\n        'status': 'unknown',\n        'config_available': BPS_CONFIG_AVAILABLE,\n        'features': {\n            'phase_locking': ENABLE_BPS_PHASE_LOCKING,\n            'charge_tracking': ENABLE_BPS_CHARGE_TRACKING,\n            'safety_checks': ENABLE_BPS_SAFETY_CHECKS\n        },\n        'issues': []\n    }\n    \n    try:\n        # Test basic oscillator creation\n        test_osc = BPSOscillator(0, 0.0, 1.0)\n        \n        # Test charge assignment\n        test_osc.assign_bps_charge(1)\n        if ENABLE_BPS_CHARGE_TRACKING and test_osc.charge != 1:\n            validation['issues'].append(\"Charge assignment failed\")\n            \n        # Test phase locking\n        initial_theta = test_osc.theta\n        test_osc.lock_to_phase(np.pi)\n        if ENABLE_BPS_PHASE_LOCKING and test_osc.theta == initial_theta:\n            validation['issues'].append(\"Phase locking not working\")\n            \n        # Test time evolution\n        test_osc.step(0.1)\n        \n        # Configuration validation\n        if BPS_CONFIG_AVAILABLE:\n            if not (0.0 <= BPS_PHASE_LOCK_GAIN <= 2.0):\n                validation['issues'].append(f\"Phase lock gain out of range: {BPS_PHASE_LOCK_GAIN}\")\n                \n            if not (0.0 <= KURAMOTO_COUPLING_STRENGTH <= 1.0):\n                validation['issues'].append(f\"Coupling strength out of range: {KURAMOTO_COUPLING_STRENGTH}\")\n                \n        # Overall status\n        if not validation['issues']:\n            validation['status'] = 'healthy'\n        elif len(validation['issues']) <= 2:\n            validation['status'] = 'warnings'\n        else:\n            validation['status'] = 'issues'\n            \n        return validation\n        \n    except Exception as e:\n        validation['status'] = 'error'\n        validation['issues'].append(f\"Validation failed: {e}\")\n        return validation\n\n# Export key components\n__all__ = [\n    'BPSOscillator',\n    'create_bps_oscillator_network',\n    'validate_bps_oscillator',\n    'BPS_CONFIG_AVAILABLE'\n]\n\nif __name__ == \"__main__\":\n    # Module verification and testing\n    logger.info(\"BPS Oscillator System loaded successfully\")\n    logger.info(f\"Config available: {'YES' if BPS_CONFIG_AVAILABLE else 'NO'}\")\n    logger.info(f\"Phase locking: {'ENABLED' if ENABLE_BPS_PHASE_LOCKING else 'DISABLED'}\")\n    logger.info(f\"Charge tracking: {'ENABLED' if ENABLE_BPS_CHARGE_TRACKING else 'DISABLED'}\")\n    \n    # Run validation if requested\n    import sys\n    if '--validate' in sys.argv or '--test' in sys.argv:\n        logger.info(\"Running oscillator validation...\")\n        validation = validate_bps_oscillator()\n        logger.info(f\"Validation status: {validation['status'].upper()}\")\n        \n        if validation['issues']:\n            logger.warning(\"Issues detected:\")\n            for issue in validation['issues']:\n                logger.warning(f\"  - {issue}\")\n        \n        if validation['status'] == 'healthy':\n            logger.info(\"All oscillator systems operational!\")\n    \n    # Demo network creation if requested\n    if '--demo' in sys.argv:\n        logger.info(\"Creating demo oscillator network...\")\n        demo_network = create_bps_oscillator_network(5, charge_density=0.4)\n        \n        logger.info(\"Demo network:\")\n        for osc in demo_network:\n            logger.info(f\"  {osc}\")\n            \n        # Test Kuramoto coupling\n        for i, osc in enumerate(demo_network):\n            others = [o for o in demo_network if o.index != i]\n            coupling = osc.kuramoto_coupling(others)\n            osc.step(0.1, coupling)\n            \n        logger.info(\"After one coupling step:\")\n        for osc in demo_network:\n            logger.info(f\"  {osc}\")\n    \n    logger.info(\"BPS oscillator initialization complete\")\n"
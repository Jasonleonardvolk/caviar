# ⚙️ **UNIFIED CONFIG MANAGEMENT TOOLS** 🎛️\n# ═══════════════════════════════════════════════════════════════════════════════\n# Runtime configuration management and control system\n# Provides dynamic configuration updates, validation, and hot-reloading\n# ═══════════════════════════════════════════════════════════════════════════════\n\nimport json\nimport logging\nimport time\nimport threading\nfrom typing import Dict, List, Any, Optional, Union, Tuple, Set, Callable\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom enum import Enum\n\n# 🌟 EPIC BPS CONFIG INTEGRATION 🌟\ntry:\n    from .bps_config import (\n        # Configuration management flags\n        ENABLE_BPS_CONFIG_MANAGEMENT, ENABLE_BPS_HOT_RELOAD, ENABLE_BPS_CONFIG_VALIDATION,\n        STRICT_BPS_MODE, ENABLE_DETAILED_LOGGING\n    )\n    \n    BPS_CONFIG_AVAILABLE = True\n    logger = logging.getLogger(__name__)\n    logger.info(\"🚀 Config Management using CENTRALIZED BPS configuration!\")\n    \nexcept ImportError:\n    logger = logging.getLogger(__name__)\n    logger.warning(\"⚠️ BPS config unavailable - using fallback constants\")\n    \n    # Feature flags (conservative defaults)\n    ENABLE_BPS_CONFIG_MANAGEMENT = True\n    ENABLE_BPS_HOT_RELOAD = True\n    ENABLE_BPS_CONFIG_VALIDATION = True\n    STRICT_BPS_MODE = False\n    ENABLE_DETAILED_LOGGING = True\n    \n    BPS_CONFIG_AVAILABLE = False\n\n# ═══════════════════════════════════════════════════════════════════════════════\n# CONFIGURATION TYPES AND STRUCTURES\n# ═══════════════════════════════════════════════════════════════════════════════\n\nclass ConfigCategory(Enum):\n    \"\"\"Categories of configuration parameters\"\"\"\n    ENERGY = \"energy\"                    # Energy and charge parameters\n    PHASE = \"phase\"                      # Phase locking and coherence\n    OSCILLATOR = \"oscillator\"            # Oscillator network settings\n    DIAGNOSTICS = \"diagnostics\"          # Monitoring and diagnostics\n    PERFORMANCE = \"performance\"          # Performance and limits\n    SYSTEM = \"system\"                    # System-level settings\n\n@dataclass\nclass ConfigParameter:\n    \"\"\"Definition of a configuration parameter\"\"\"\n    name: str\n    category: ConfigCategory\n    current_value: Any\n    default_value: Any\n    data_type: type\n    description: str\n    \n    # Validation constraints\n    min_value: Optional[float] = None\n    max_value: Optional[float] = None\n    hot_reloadable: bool = True\n    \n    # Change tracking\n    last_updated: Optional[float] = None\n    update_count: int = 0\n\n@dataclass\nclass ConfigChangeEvent:\n    \"\"\"Record of a configuration change\"\"\"\n    timestamp: float\n    parameter_name: str\n    old_value: Any\n    new_value: Any\n    changed_by: str\n    applied_successfully: bool\n\n# ═══════════════════════════════════════════════════════════════════════════════\n# UNIFIED CONFIG MANAGEMENT SYSTEM\n# ═══════════════════════════════════════════════════════════════════════════════\n\nclass UnifiedConfigManager:\n    \"\"\"\n    ⚙️ UNIFIED CONFIG MANAGEMENT SYSTEM - THE CONTROL CENTER! 🎛️\n    \n    Features:\n    • Dynamic configuration updates with validation\n    • Hot-reloading of parameters without restart\n    • Configuration persistence and versioning\n    • Real-time parameter monitoring\n    • Integration with all BPS subsystems\n    \"\"\"\n    \n    def __init__(self, base_path: Union[str, Path], manager_name: str = \"config_manager\"):\n        \"\"\"\n        Initialize the unified config manager\n        \n        Args:\n            base_path: Base directory for configuration storage\n            manager_name: Unique name for this manager\n        \"\"\"\n        self.base_path = Path(base_path)\n        self.manager_name = manager_name\n        self.manager_path = self.base_path / manager_name\n        \n        # 🎛️ Configuration\n        self.config_available = BPS_CONFIG_AVAILABLE\n        self.strict_mode = STRICT_BPS_MODE\n        \n        # 📊 Parameter registry\n        self.parameters: Dict[str, ConfigParameter] = {}\n        self.parameter_lock = threading.RLock()\n        \n        # 📝 Change tracking\n        self.change_history: List[ConfigChangeEvent] = []\n        self.change_lock = threading.RLock()\n        \n        # 🔧 Runtime state\n        self.creation_time = time.time()\n        self.last_save = None\n        self.total_updates = 0\n        self.failed_updates = 0\n        \n        # 🎯 Subsystem references\n        self.registered_subsystems: Dict[str, Any] = {}\n        \n        # Initialize manager\n        self._initialize_manager()\n        \n        logger.info(f\"🚀 Config Manager '{manager_name}' ACTIVATED!\")\n        logger.info(f\"📍 Location: {self.manager_path}\")\n        logger.info(f\"⚡ BPS Config: {'ENABLED' if self.config_available else 'FALLBACK'}\")\n    \n    def _initialize_manager(self):\n        \"\"\"Initialize manager and register demo parameters\"\"\"\n        try:\n            self.manager_path.mkdir(parents=True, exist_ok=True)\n            \n            # Create subdirectories\n            (self.manager_path / \"configs\").mkdir(exist_ok=True)\n            (self.manager_path / \"backups\").mkdir(exist_ok=True)\n            (self.manager_path / \"history\").mkdir(exist_ok=True)\n            \n            # Register some demo BPS parameters\n            self._register_demo_parameters()\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize config manager: {e}\")\n            if self.strict_mode:\n                raise RuntimeError(f\"Config manager initialization failed: {e}\")\n    \n    def _register_demo_parameters(self):\n        \"\"\"Register demo BPS configuration parameters for management\"\"\"\n        logger.info(\"📝 Registering demo BPS configuration parameters...\")\n        \n        # Energy and charge parameters\n        self._register_parameter(\n            \"ENERGY_PER_Q\", ConfigCategory.ENERGY, 1.0, float,\n            \"Energy per unit charge\", min_value=0.1, max_value=10.0\n        )\n        \n        self._register_parameter(\n            \"CHARGE_CONSERVATION_TOLERANCE\", ConfigCategory.ENERGY, 1e-10, float,\n            \"Charge conservation tolerance\", min_value=1e-12, max_value=1e-6\n        )\n        \n        # Phase locking parameters\n        self._register_parameter(\n            \"BPS_PHASE_LOCK_GAIN\", ConfigCategory.PHASE, 0.5, float,\n            \"Phase locking gain\", min_value=0.0, max_value=2.0\n        )\n        \n        self._register_parameter(\n            \"KURAMOTO_COUPLING_STRENGTH\", ConfigCategory.PHASE, 0.3, float,\n            \"Kuramoto coupling strength\", min_value=0.0, max_value=1.0\n        )\n        \n        # Oscillator network parameters\n        self._register_parameter(\n            \"OSCILLATOR_NETWORK_UPDATE_RATE\", ConfigCategory.OSCILLATOR, 60.0, float,\n            \"Oscillator network update rate (Hz)\", min_value=1.0, max_value=1000.0\n        )\n        \n        # Diagnostics parameters\n        self._register_parameter(\n            \"DIAGNOSTICS_UPDATE_INTERVAL\", ConfigCategory.DIAGNOSTICS, 30.0, float,\n            \"Diagnostics update interval (seconds)\", min_value=1.0, max_value=300.0\n        )\n        \n        # Performance parameters\n        self._register_parameter(\n            \"SLOW_OPERATION_THRESHOLD\", ConfigCategory.PERFORMANCE, 1.0, float,\n            \"Slow operation threshold (seconds)\", min_value=0.1, max_value=10.0\n        )\n        \n        self._register_parameter(\n            \"PERFORMANCE_PROFILING_ENABLED\", ConfigCategory.PERFORMANCE, False, bool,\n            \"Enable performance profiling\"\n        )\n        \n        logger.info(f\"📝 Registered {len(self.parameters)} demo BPS configuration parameters\")\n    \n    def _register_parameter(self, name: str, category: ConfigCategory, current_value: Any,\n                          data_type: type, description: str, **kwargs):\n        \"\"\"Register a configuration parameter\"\"\"\n        parameter = ConfigParameter(\n            name=name,\n            category=category,\n            current_value=current_value,\n            default_value=current_value,\n            data_type=data_type,\n            description=description,\n            **kwargs\n        )\n        \n        self.parameters[name] = parameter\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"Registered parameter: {name} = {current_value}\")\n    \n    def get_parameter(self, name: str) -> Any:\n        \"\"\"Get current value of a configuration parameter\"\"\"\n        with self.parameter_lock:\n            if name not in self.parameters:\n                raise ValueError(f\"Unknown parameter: {name}\")\n            return self.parameters[name].current_value\n    \n    def set_parameter(self, name: str, value: Any, changed_by: str = \"user\", \n                     validate: bool = True) -> bool:\n        \"\"\"Set a configuration parameter with validation\"\"\"\n        if not ENABLE_BPS_CONFIG_MANAGEMENT:\n            logger.warning(\"Config management disabled\")\n            return False\n        \n        with self.parameter_lock:\n            if name not in self.parameters:\n                logger.error(f\"Unknown parameter: {name}\")\n                return False\n            \n            parameter = self.parameters[name]\n            old_value = parameter.current_value\n            \n            # Validate the new value\n            if validate:\n                validation_result = self._validate_parameter_value(parameter, value)\n                if validation_result != \"valid\":\n                    logger.error(f\"Parameter validation failed for {name}: {validation_result}\")\n                    \n                    # Record failed change\n                    self._record_change_event(\n                        name, old_value, value, changed_by, False\n                    )\n                    return False\n            \n            try:\n                # Update parameter\n                parameter.current_value = value\n                parameter.last_updated = time.time()\n                parameter.update_count += 1\n                \n                # Record successful change\n                self._record_change_event(\n                    name, old_value, value, changed_by, True\n                )\n                \n                self.total_updates += 1\n                \n                # Notify subsystems if hot-reloadable\n                if parameter.hot_reloadable and ENABLE_BPS_HOT_RELOAD:\n                    self._notify_subsystems_of_change(name, old_value, value)\n                \n                logger.info(f\"✅ Parameter updated: {name} = {value} (was {old_value})\")\n                return True\n                \n            except Exception as e:\n                # Rollback on error\n                parameter.current_value = old_value\n                error_msg = f\"Failed to update parameter {name}: {e}\"\n                logger.error(error_msg)\n                \n                self._record_change_event(\n                    name, old_value, value, changed_by, False\n                )\n                \n                self.failed_updates += 1\n                return False\n    \n    def _validate_parameter_value(self, parameter: ConfigParameter, value: Any) -> str:\n        \"\"\"Validate a parameter value against constraints\"\"\"\n        try:\n            # Type validation\n            if not isinstance(value, parameter.data_type):\n                # Try to convert\n                try:\n                    value = parameter.data_type(value)\n                except (ValueError, TypeError):\n                    return f\"Invalid type: expected {parameter.data_type.__name__}, got {type(value).__name__}\"\n            \n            # Range validation for numeric types\n            if isinstance(value, (int, float)):\n                if parameter.min_value is not None and value < parameter.min_value:\n                    return f\"Value {value} below minimum {parameter.min_value}\"\n                if parameter.max_value is not None and value > parameter.max_value:\n                    return f\"Value {value} above maximum {parameter.max_value}\"\n            \n            return \"valid\"\n            \n        except Exception as e:\n            return f\"Validation error: {e}\"\n    \n    def _record_change_event(self, name: str, old_value: Any, new_value: Any,\n                           changed_by: str, success: bool):\n        \"\"\"Record a configuration change event\"\"\"\n        with self.change_lock:\n            event = ConfigChangeEvent(\n                timestamp=time.time(),\n                parameter_name=name,\n                old_value=old_value,\n                new_value=new_value,\n                changed_by=changed_by,\n                applied_successfully=success\n            )\n            \n            self.change_history.append(event)\n            \n            # Keep history bounded\n            if len(self.change_history) > 1000:\n                self.change_history = self.change_history[-500:]\n    \n    def _notify_subsystems_of_change(self, name: str, old_value: Any, new_value: Any):\n        \"\"\"Notify registered subsystems of parameter changes\"\"\"\n        for subsystem_name, subsystem in self.registered_subsystems.items():\n            try:\n                # Call hot-reload method if available\n                if hasattr(subsystem, 'hot_reload_config'):\n                    subsystem.hot_reload_config(name, new_value)\n                    logger.debug(f\"Notified {subsystem_name} of config change: {name}\")\n                \n            except Exception as e:\n                logger.warning(f\"Failed to notify {subsystem_name} of config change: {e}\")\n    \n    def register_subsystem(self, name: str, subsystem: Any):\n        \"\"\"Register a subsystem for configuration change notifications\"\"\"\n        self.registered_subsystems[name] = subsystem\n        logger.info(f\"📝 Registered subsystem {name} for config notifications\")\n    \n    def get_configuration_summary(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive configuration summary\"\"\"\n        with self.parameter_lock:\n            # Group parameters by category\n            by_category = {}\n            for param in self.parameters.values():\n                category = param.category.value\n                if category not in by_category:\n                    by_category[category] = []\n                \n                by_category[category].append({\n                    'name': param.name,\n                    'current_value': param.current_value,\n                    'default_value': param.default_value,\n                    'description': param.description,\n                    'last_updated': param.last_updated,\n                    'update_count': param.update_count,\n                    'hot_reloadable': param.hot_reloadable\n                })\n            \n            # Recent changes\n            recent_changes = [\n                {\n                    'timestamp': event.timestamp,\n                    'parameter': event.parameter_name,\n                    'old_value': event.old_value,\n                    'new_value': event.new_value,\n                    'changed_by': event.changed_by,\n                    'success': event.applied_successfully\n                }\n                for event in self.change_history[-10:]  # Last 10 changes\n            ]\n            \n            return {\n                'manager_name': self.manager_name,\n                'total_parameters': len(self.parameters),\n                'parameters_by_category': by_category,\n                'total_updates': self.total_updates,\n                'failed_updates': self.failed_updates,\n                'recent_changes': recent_changes,\n                'registered_subsystems': list(self.registered_subsystems.keys()),\n                'last_save': self.last_save,\n                'config_available': self.config_available\n            }\n    \n    def save_configuration(self, filename: str = None) -> bool:\n        \"\"\"Save current configuration to file\"\"\"\n        if filename is None:\n            filename = f\"config_{int(time.time())}.json\"\n        \n        config_file = self.manager_path / \"configs\" / filename\n        \n        try:\n            # Create configuration data\n            config_data = {\n                'metadata': {\n                    'saved_at': time.time(),\n                    'manager_name': self.manager_name,\n                    'version': '1.0'\n                },\n                'parameters': {}\n            }\n            \n            # Add all parameters\n            with self.parameter_lock:\n                for name, param in self.parameters.items():\n                    config_data['parameters'][name] = {\n                        'value': param.current_value,\n                        'category': param.category.value,\n                        'last_updated': param.last_updated,\n                        'update_count': param.update_count\n                    }\n            \n            # Save to file\n            with open(config_file, 'w') as f:\n                json.dump(config_data, f, indent=2)\n            \n            self.last_save = time.time()\n            logger.info(f\"💾 Configuration saved to {config_file}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to save configuration: {e}\")\n            return False\n    \n    def reset_parameter(self, name: str) -> bool:\n        \"\"\"Reset a parameter to its default value\"\"\"\n        if name not in self.parameters:\n            logger.error(f\"Unknown parameter: {name}\")\n            return False\n        \n        default_value = self.parameters[name].default_value\n        return self.set_parameter(name, default_value, \"reset\", validate=True)\n    \n    def __repr__(self):\n        return (f\"<UnifiedConfigManager '{self.manager_name}' \"\n                f\"parameters={len(self.parameters)} updates={self.total_updates}>\")\n\n# ═══════════════════════════════════════════════════════════════════════════════\n# UTILITY FUNCTIONS\n# ═══════════════════════════════════════════════════════════════════════════════\n\ndef create_config_manager(base_path: str = \"/tmp\") -> UnifiedConfigManager:\n    \"\"\"Create and initialize a config manager\"\"\"\n    manager = UnifiedConfigManager(base_path, \"production_config_manager\")\n    \n    logger.info(f\"⚙️ Config Manager created with {len(manager.parameters)} parameters\")\n    return manager\n\ndef validate_config_manager(manager: UnifiedConfigManager) -> Dict[str, Any]:\n    \"\"\"Comprehensive validation of config manager\"\"\"\n    validation = {\n        'status': 'unknown',\n        'issues': [],\n        'manager_summary': manager.get_configuration_summary()\n    }\n    \n    try:\n        summary = validation['manager_summary']\n        \n        # Check if parameters are properly registered\n        if summary['total_parameters'] == 0:\n            validation['issues'].append(\"No parameters registered\")\n        \n        # Check for failed updates\n        if summary['failed_updates'] > summary['total_updates'] * 0.1:  # More than 10% failure rate\n            validation['issues'].append(f\"High update failure rate: {summary['failed_updates']}/{summary['total_updates']}\")\n        \n        # Overall status\n        if not validation['issues']:\n            validation['status'] = 'excellent'\n        elif len(validation['issues']) <= 2:\n            validation['status'] = 'good'\n        else:\n            validation['status'] = 'issues_detected'\n        \n        return validation\n        \n    except Exception as e:\n        validation['status'] = 'error'\n        validation['issues'].append(f\"Validation failed: {e}\")\n        return validation\n\n# Export all components\n__all__ = [\n    'UnifiedConfigManager',\n    'ConfigCategory',\n    'ConfigParameter',\n    'ConfigChangeEvent',\n    'create_config_manager',\n    'validate_config_manager',\n    'BPS_CONFIG_AVAILABLE'\n]\n\nif __name__ == \"__main__\":\n    # 🎪 DEMONSTRATION MODE!\n    logger.info(\"🚀 UNIFIED CONFIG MANAGEMENT SYSTEM ACTIVATED!\")\n    logger.info(f\"⚡ Config: {'CENTRALIZED' if BPS_CONFIG_AVAILABLE else 'FALLBACK MODE'}\")\n    \n    import sys\n    if '--demo' in sys.argv:\n        logger.info(\"🎪 Creating demo config manager...\")\n        \n        manager = create_config_manager()\n        \n        # Show current configuration\n        logger.info(\"📊 Configuration Summary:\")\n        summary = manager.get_configuration_summary()\n        logger.info(f\"  Total Parameters: {summary['total_parameters']}\")\n        logger.info(f\"  Categories: {list(summary['parameters_by_category'].keys())}\")\n        \n        # Demonstrate parameter updates\n        logger.info(\"🔧 Testing parameter updates...\")\n        \n        # Test valid update\n        success = manager.set_parameter(\"ENERGY_PER_Q\", 1.5, \"demo\")\n        logger.info(f\"Energy update: {'✅ SUCCESS' if success else '❌ FAILED'}\")\n        \n        # Test invalid update (should fail)\n        success = manager.set_parameter(\"ENERGY_PER_Q\", -1.0, \"demo\")\n        logger.info(f\"Invalid energy update: {'❌ UNEXPECTED SUCCESS' if success else '✅ CORRECTLY FAILED'}\")\n        \n        # Save configuration\n        success = manager.save_configuration(\"demo_config.json\")\n        logger.info(f\"Config save: {'✅ SUCCESS' if success else '❌ FAILED'}\")\n    \n    if '--validate' in sys.argv and '--demo' in sys.argv:\n        logger.info(\"🔍 Running comprehensive validation...\")\n        validation = validate_config_manager(manager)\n        logger.info(f\"Overall validation: {validation['status'].upper()}\")\n        if validation['issues']:\n            for issue in validation['issues']:\n                logger.warning(f\"  Issue: {issue}\")\n    \n    logger.info(\"🎯 Unified Config Management System ready for PRODUCTION use!\")\n"
# ðŸŒŠ **UNIFIED OSCILLATOR NETWORK MANAGER** âš¡\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# Master oscillator coordination system with complete BPS configuration integration\n# Manages oscillator lattices, BPS oscillators, and phase synchronization networks\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nimport asyncio\nimport logging\nimport time\nimport threading\nfrom typing import Dict, List, Any, Optional, Union, Tuple, Set, Callable\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom enum import Enum\nimport numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\n# ðŸŒŸ EPIC BPS CONFIG INTEGRATION ðŸŒŸ\ntry:\n    from .bps_config import (\n        # Feature flags for oscillator network control\n        ENABLE_BPS_OSCILLATOR_NETWORK, ENABLE_BPS_PHASE_SYNC, ENABLE_BPS_ADAPTIVE_COUPLING,\n        ENABLE_BPS_PHASE_LOCKING, ENABLE_BPS_CHARGE_TRACKING, ENABLE_BPS_SAFETY_CHECKS,\n        STRICT_BPS_MODE, ENABLE_DETAILED_LOGGING, ENABLE_BPS_DIAGNOSTICS,\n        \n        # Oscillator network parameters\n        OSCILLATOR_NETWORK_UPDATE_RATE, MAX_OSCILLATOR_NETWORKS, NETWORK_SYNC_TOLERANCE,\n        PHASE_COHERENCE_THRESHOLD, BPS_PHASE_LOCK_GAIN, KURAMOTO_COUPLING_STRENGTH,\n        MAX_PHASE_CORRECTION, ADAPTIVE_COUPLING_RATE,\n        \n        # Charge and energy parameters\n        ENERGY_PER_Q, CHARGE_CONSERVATION_TOLERANCE, MAX_ALLOWED_CHARGE_MAGNITUDE,\n        \n        # Performance parameters\n        PERFORMANCE_PROFILING_ENABLED, SLOW_OPERATION_THRESHOLD, MAX_OSCILLATOR_COUNT,\n        \n        # Network topology parameters\n        DEFAULT_NETWORK_SIZE, DEFAULT_COUPLING_RADIUS, NETWORK_HEALTH_CHECK_INTERVAL,\n        \n        # Symbolic tags\n        NETWORK_TAGS, OSCILLATOR_TAGS, STATE_TAGS\n    )\n    \n    BPS_CONFIG_AVAILABLE = True\n    logger = logging.getLogger(__name__)\n    logger.info(\"ðŸš€ Oscillator Network Manager using CENTRALIZED BPS configuration!\")\n    \nexcept ImportError:\n    logger = logging.getLogger(__name__)\n    logger.warning(\"âš ï¸ BPS config unavailable - using fallback constants\")\n    \n    # Feature flags (conservative defaults)\n    ENABLE_BPS_OSCILLATOR_NETWORK = True\n    ENABLE_BPS_PHASE_SYNC = True\n    ENABLE_BPS_ADAPTIVE_COUPLING = True\n    ENABLE_BPS_PHASE_LOCKING = True\n    ENABLE_BPS_CHARGE_TRACKING = True\n    ENABLE_BPS_SAFETY_CHECKS = True\n    STRICT_BPS_MODE = False\n    ENABLE_DETAILED_LOGGING = True\n    ENABLE_BPS_DIAGNOSTICS = True\n    \n    # Network parameters\n    OSCILLATOR_NETWORK_UPDATE_RATE = 60.0  # Hz\n    MAX_OSCILLATOR_NETWORKS = 20\n    NETWORK_SYNC_TOLERANCE = 0.1\n    PHASE_COHERENCE_THRESHOLD = 0.1\n    BPS_PHASE_LOCK_GAIN = 0.5\n    KURAMOTO_COUPLING_STRENGTH = 0.3\n    MAX_PHASE_CORRECTION = 0.5\n    ADAPTIVE_COUPLING_RATE = 0.1\n    \n    # Energy and charge\n    ENERGY_PER_Q = 1.0\n    CHARGE_CONSERVATION_TOLERANCE = 1e-10\n    MAX_ALLOWED_CHARGE_MAGNITUDE = 2\n    \n    # Performance\n    PERFORMANCE_PROFILING_ENABLED = False\n    SLOW_OPERATION_THRESHOLD = 1.0\n    MAX_OSCILLATOR_COUNT = 10000\n    \n    # Network topology\n    DEFAULT_NETWORK_SIZE = 100\n    DEFAULT_COUPLING_RADIUS = 5\n    NETWORK_HEALTH_CHECK_INTERVAL = 30.0\n    \n    # Tags\n    NETWORK_TAGS = {'synchronized': \"Synchronized\", 'chaotic': \"Chaotic\"}\n    OSCILLATOR_TAGS = {'coupled': \"Coupled\", 'isolated': \"Isolated\"}\n    STATE_TAGS = {'coherent': \"Coherent\", 'incoherent': \"Incoherent\"}\n    \n    BPS_CONFIG_AVAILABLE = False\n\n# Import oscillator components with graceful fallbacks\ntry:\n    from .bps_oscillator import BPSOscillator, create_bps_oscillator_network\n    BPS_OSCILLATOR_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\"BPS oscillator not available\")\n    BPS_OSCILLATOR_AVAILABLE = False\n    \n    # Minimal fallback oscillator\n    class BPSOscillator:\n        def __init__(self, index, theta=0.0, omega=0.0):\n            self.index = index\n            self.theta = theta\n            self.omega = omega\n            self.charge = 0\n            self.phase_locked = False\n        \n        def step(self, dt=1.0, coupling=0.0):\n            self.theta += self.omega * dt + coupling\n            self.theta %= (2 * np.pi)\n        \n        def assign_bps_charge(self, q):\n            self.charge = int(np.sign(q)) if abs(q) > 0.5 else 0\n    \n    def create_bps_oscillator_network(count, omega_range=(0.5, 1.5), charge_density=0.1):\n        return [BPSOscillator(i) for i in range(count)]\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# OSCILLATOR NETWORK TYPES AND STRUCTURES\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nclass NetworkTopology(Enum):\n    \"\"\"Types of oscillator network topologies\"\"\"\n    RING = \"ring\"                    # Ring topology\n    GRID = \"grid\"                    # 2D grid topology\n    SMALL_WORLD = \"small_world\"      # Small-world network\n    ALL_TO_ALL = \"all_to_all\"        # Fully connected\n    CUSTOM = \"custom\"                # Custom connectivity\n\nclass NetworkState(Enum):\n    \"\"\"Network synchronization states\"\"\"\n    COHERENT = \"coherent\"            # High phase coherence\n    INCOHERENT = \"incoherent\"        # Random phases\n    CLUSTERED = \"clustered\"          # Cluster synchronization\n    CHIMERA = \"chimera\"              # Chimera states\n\n@dataclass\nclass OscillatorNetworkInfo:\n    \"\"\"Information about an oscillator network\"\"\"\n    network_id: str\n    topology: NetworkTopology\n    oscillators: List[BPSOscillator]\n    coupling_matrix: Optional[np.ndarray] = None\n    \n    # Network state\n    current_state: NetworkState = NetworkState.INCOHERENT\n    phase_coherence: float = 0.0\n    sync_parameter: float = 0.0\n    \n    # BPS properties\n    total_charge: int = 0\n    charge_distribution: Dict[int, int] = field(default_factory=dict)\n    energy_content: float = 0.0\n    \n    # Performance metrics\n    update_count: int = 0\n    last_update: float = field(default_factory=time.time)\n    avg_update_time: float = 0.0\n    \n    # Health status\n    health_status: str = \"unknown\"\n    error_count: int = 0\n    last_health_check: float = field(default_factory=time.time)\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# UNIFIED OSCILLATOR NETWORK MANAGER\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nclass UnifiedOscillatorNetworkManager:\n    \"\"\"\n    ðŸŒŠ UNIFIED OSCILLATOR NETWORK MANAGER - THE WAVE CONDUCTOR! âš¡\n    \n    Features:\n    â€¢ Manages multiple oscillator networks with different topologies\n    â€¢ BPS-aware phase synchronization and charge tracking\n    â€¢ Adaptive coupling with configuration-driven parameters\n    â€¢ Real-time network state analysis and health monitoring\n    â€¢ Performance optimization with parallel processing\n    â€¢ Conservation law enforcement across networks\n    \"\"\"\n    \n    def __init__(self, base_path: Union[str, Path], manager_name: str = \"oscillator_network_manager\"):\n        \"\"\"\n        Initialize the unified oscillator network manager\n        \n        Args:\n            base_path: Base directory for network storage\n            manager_name: Unique name for this manager\n        \"\"\"\n        self.base_path = Path(base_path)\n        self.manager_name = manager_name\n        self.manager_path = self.base_path / manager_name\n        \n        # ðŸŽ›ï¸ Configuration\n        self.config_available = BPS_CONFIG_AVAILABLE\n        self.strict_mode = STRICT_BPS_MODE\n        \n        # ðŸŒŠ Network registry\n        self.networks: Dict[str, OscillatorNetworkInfo] = {}\n        self.network_lock = threading.RLock()\n        \n        # âš¡ Global synchronization tracking\n        self.global_phase_coherence: float = 0.0\n        self.global_charge: int = 0\n        self.global_energy: float = 0.0\n        self.sync_history: List[Dict[str, Any]] = []\n        \n        # ðŸŽ¯ Performance metrics\n        self.total_oscillators: int = 0\n        self.update_count: int = 0\n        self.sync_count: int = 0\n        self.creation_time: float = time.time()\n        \n        # ðŸ”§ Background processing\n        self.update_executor = ThreadPoolExecutor(max_workers=4, thread_name_prefix=\"OscNet\")\n        self.background_tasks: Set[asyncio.Task] = set()\n        self.shutdown_event = asyncio.Event()\n        \n        # Initialize manager\n        self._initialize_manager()\n        \n        logger.info(f\"ðŸš€ Oscillator Network Manager '{manager_name}' ACTIVATED!\")\n        logger.info(f\"ðŸ“ Location: {self.manager_path}\")\n        logger.info(f\"âš¡ BPS Config: {'ENABLED' if self.config_available else 'FALLBACK'}\")\n        logger.info(f\"ðŸ”’ Strict Mode: {'ON' if self.strict_mode else 'OFF'}\")\n    \n    def _initialize_manager(self):\n        \"\"\"Initialize manager directory and auto-discover networks\"\"\"\n        try:\n            self.manager_path.mkdir(parents=True, exist_ok=True)\n            \n            # Create subdirectories for different network types\n            (self.manager_path / \"ring_networks\").mkdir(exist_ok=True)\n            (self.manager_path / \"grid_networks\").mkdir(exist_ok=True)\n            (self.manager_path / \"custom_networks\").mkdir(exist_ok=True)\n            (self.manager_path / \"logs\").mkdir(exist_ok=True)\n            (self.manager_path / \"metrics\").mkdir(exist_ok=True)\n            \n            # Auto-discover existing networks\n            self._auto_discover_networks()\n            \n            # Start background tasks if enabled\n            if ENABLE_BPS_OSCILLATOR_NETWORK:\n                self._schedule_background_tasks()\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize manager: {e}\")\n            if self.strict_mode:\n                raise RuntimeError(f\"Manager initialization failed: {e}\")\n    \n    def _auto_discover_networks(self):\n        \"\"\"Auto-discover existing oscillator networks\"\"\"\n        logger.info(\"ðŸ” Auto-discovering oscillator networks...\")\n        \n        discovered_count = 0\n        \n        # Try to create a default demo network\n        try:\n            self.create_network(\"demo_ring\", NetworkTopology.RING, size=10)\n            discovered_count += 1\n            logger.info(\"âœ… Demo ring network created\")\n        except Exception as e:\n            logger.warning(f\"Failed to create demo network: {e}\")\n        \n        logger.info(f\"ðŸ” Auto-discovery complete: {discovered_count} networks created\")\n    \n    def create_network(self, network_id: str, topology: NetworkTopology, \n                      size: int = None, **topology_params) -> str:\n        \"\"\"Create a new oscillator network with specified topology\"\"\"\n        with self.network_lock:\n            if len(self.networks) >= MAX_OSCILLATOR_NETWORKS:\n                error_msg = f\"Maximum networks ({MAX_OSCILLATOR_NETWORKS}) reached\"\n                logger.warning(error_msg)\n                if self.strict_mode:\n                    raise RuntimeError(error_msg)\n                return None\n            \n            if network_id in self.networks:\n                error_msg = f\"Network {network_id} already exists\"\n                logger.warning(error_msg)\n                if self.strict_mode:\n                    raise ValueError(error_msg)\n                return None\n            \n            # Use default size if not specified\n            if size is None:\n                size = min(DEFAULT_NETWORK_SIZE, MAX_OSCILLATOR_COUNT)\n            \n            # Validate size\n            if size > MAX_OSCILLATOR_COUNT:\n                error_msg = f\"Network size {size} exceeds maximum {MAX_OSCILLATOR_COUNT}\"\n                logger.warning(error_msg)\n                if self.strict_mode:\n                    raise ValueError(error_msg)\n                size = MAX_OSCILLATOR_COUNT\n            \n            try:\n                # Create oscillators\n                oscillators = create_bps_oscillator_network(\n                    size, \n                    charge_density=topology_params.get('charge_density', 0.1)\n                )\n                \n                # Create coupling matrix based on topology\n                coupling_matrix = self._create_coupling_matrix(topology, size, **topology_params)\n                \n                # Create network info\n                network_info = OscillatorNetworkInfo(\n                    network_id=network_id,\n                    topology=topology,\n                    oscillators=oscillators,\n                    coupling_matrix=coupling_matrix\n                )\n                \n                # Initialize network state\n                self._initialize_network_state(network_info)\n                \n                # Register network\n                self.networks[network_id] = network_info\n                self.total_oscillators += len(oscillators)\n                \n                logger.info(f\"ðŸ“ Created network: {network_id} ({topology.value}, {size} oscillators)\")\n                return network_id\n                \n            except Exception as e:\n                error_msg = f\"Failed to create network {network_id}: {e}\"\n                logger.error(error_msg)\n                if self.strict_mode:\n                    raise RuntimeError(error_msg)\n                return None\n    \n    def _create_coupling_matrix(self, topology: NetworkTopology, size: int, \n                               **params) -> np.ndarray:\n        \"\"\"Create coupling matrix for specified topology\"\"\"\n        coupling_matrix = np.zeros((size, size))\n        \n        if topology == NetworkTopology.RING:\n            # Ring topology - each node connected to neighbors\n            for i in range(size):\n                coupling_matrix[i, (i + 1) % size] = KURAMOTO_COUPLING_STRENGTH\n                coupling_matrix[i, (i - 1) % size] = KURAMOTO_COUPLING_STRENGTH\n        \n        elif topology == NetworkTopology.GRID:\n            # 2D grid topology\n            grid_size = int(np.sqrt(size))\n            for i in range(size):\n                row, col = i // grid_size, i % grid_size\n                \n                # Connect to grid neighbors\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nr, nc = row + dr, col + dc\n                    if 0 <= nr < grid_size and 0 <= nc < grid_size:\n                        neighbor = nr * grid_size + nc\n                        coupling_matrix[i, neighbor] = KURAMOTO_COUPLING_STRENGTH\n        \n        elif topology == NetworkTopology.ALL_TO_ALL:\n            # Fully connected network\n            coupling_matrix.fill(KURAMOTO_COUPLING_STRENGTH)\n            np.fill_diagonal(coupling_matrix, 0)  # No self-coupling\n        \n        elif topology == NetworkTopology.SMALL_WORLD:\n            # Small-world network (simplified)\n            k = params.get('k', 4)  # Number of nearest neighbors\n            \n            # Start with ring lattice\n            for i in range(size):\n                for j in range(1, k // 2 + 1):\n                    coupling_matrix[i, (i + j) % size] = KURAMOTO_COUPLING_STRENGTH\n                    coupling_matrix[i, (i - j) % size] = KURAMOTO_COUPLING_STRENGTH\n        \n        return coupling_matrix\n    \n    def _initialize_network_state(self, network_info: OscillatorNetworkInfo):\n        \"\"\"Initialize network state and BPS properties\"\"\"\n        # Compute charge distribution\n        charge_counts = {}\n        total_charge = 0\n        \n        for osc in network_info.oscillators:\n            charge = getattr(osc, 'charge', 0)\n            total_charge += charge\n            charge_counts[charge] = charge_counts.get(charge, 0) + 1\n        \n        network_info.total_charge = total_charge\n        network_info.charge_distribution = charge_counts\n        \n        # Compute initial phase coherence\n        network_info.phase_coherence = self._compute_phase_coherence(network_info.oscillators)\n        \n        # Estimate energy content\n        network_info.energy_content = abs(total_charge) * ENERGY_PER_Q + \\\n                                    len(network_info.oscillators) * 0.1\n        \n        # Determine initial state\n        if network_info.phase_coherence > 0.8:\n            network_info.current_state = NetworkState.COHERENT\n        elif network_info.phase_coherence < 0.2:\n            network_info.current_state = NetworkState.INCOHERENT\n        else:\n            network_info.current_state = NetworkState.CLUSTERED\n        \n        network_info.health_status = \"healthy\"\n        \n        if ENABLE_DETAILED_LOGGING:\n            logger.debug(f\"ðŸŒŠ Network {network_info.network_id} initialized: \"\n                        f\"Q={total_charge}, coherence={network_info.phase_coherence:.3f}\")\n    \n    def _compute_phase_coherence(self, oscillators: List[BPSOscillator]) -> float:\n        \"\"\"Compute phase coherence of oscillator network\"\"\"\n        if not oscillators:\n            return 0.0\n        \n        # Compute complex order parameter\n        exp_sum = sum(np.exp(1j * osc.theta) for osc in oscillators)\n        coherence = abs(exp_sum) / len(oscillators)\n        \n        return coherence\n    \n    def update_network(self, network_id: str, dt: float = None) -> Dict[str, Any]:\n        \"\"\"Update a specific network for one time step\"\"\"\n        if not ENABLE_BPS_OSCILLATOR_NETWORK:\n            return {'status': 'disabled'}\n        \n        if dt is None:\n            dt = 1.0 / OSCILLATOR_NETWORK_UPDATE_RATE\n        \n        with self.network_lock:\n            if network_id not in self.networks:\n                return {'status': 'not_found', 'error': f'Network {network_id} not found'}\n            \n            network_info = self.networks[network_id]\n            \n            try:\n                start_time = time.time() if PERFORMANCE_PROFILING_ENABLED else 0.0\n                \n                oscillators = network_info.oscillators\n                coupling_matrix = network_info.coupling_matrix\n                \n                # Update all oscillators\n                for i, osc in enumerate(oscillators):\n                    coupling_term = 0.0\n                    \n                    # Compute coupling if matrix exists\n                    if coupling_matrix is not None:\n                        for j, other in enumerate(oscillators):\n                            if i != j and coupling_matrix[i, j] > 0:\n                                coupling_term += coupling_matrix[i, j] * np.sin(other.theta - osc.theta)\n                    \n                    osc.step(dt, coupling_term)\n                \n                # Update network state\n                network_info.phase_coherence = self._compute_phase_coherence(oscillators)\n                network_info.update_count += 1\n                network_info.last_update = time.time()\n                \n                if PERFORMANCE_PROFILING_ENABLED:\n                    update_time = time.time() - start_time\n                    network_info.avg_update_time = (\n                        (network_info.avg_update_time * (network_info.update_count - 1) + update_time) /\n                        network_info.update_count\n                    )\n                    \n                    if update_time > SLOW_OPERATION_THRESHOLD / 1000:\n                        logger.warning(f\"Slow network update {network_id}: {update_time*1000:.2f}ms\")\n                \n                return {\n                    'status': 'updated',\n                    'phase_coherence': network_info.phase_coherence,\n                    'current_state': network_info.current_state.value,\n                    'update_time': update_time if PERFORMANCE_PROFILING_ENABLED else 0.0\n                }\n                \n            except Exception as e:\n                network_info.error_count += 1\n                error_msg = f\"Network update failed for {network_id}: {e}\"\n                logger.error(error_msg)\n                \n                return {\n                    'status': 'error',\n                    'error': error_msg,\n                    'error_count': network_info.error_count\n                }\n    \n    def get_manager_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive manager status\"\"\"\n        with self.network_lock:\n            # Network statistics\n            network_states = {}\n            for state in NetworkState:\n                network_states[state.value] = sum(\n                    1 for net in self.networks.values() \n                    if net.current_state == state\n                )\n            \n            # Health statistics\n            healthy_networks = sum(\n                1 for net in self.networks.values() \n                if net.health_status == \"healthy\"\n            )\n            \n            # Global metrics\n            total_charge = sum(net.total_charge for net in self.networks.values())\n            avg_coherence = np.mean([net.phase_coherence for net in self.networks.values()]) if self.networks else 0.0\n            \n            return {\n                'manager_name': self.manager_name,\n                'total_networks': len(self.networks),\n                'total_oscillators': self.total_oscillators,\n                'healthy_networks': healthy_networks,\n                'network_states': network_states,\n                'global_phase_coherence': avg_coherence,\n                'global_charge': total_charge,\n                'update_count': self.update_count,\n                'uptime_seconds': time.time() - self.creation_time,\n                'config_available': self.config_available,\n                'strict_mode': self.strict_mode\n            }\n    \n    def _schedule_background_tasks(self):\n        \"\"\"Schedule background maintenance tasks\"\"\"\n        # Background tasks would go here if async is available\n        logger.info(\"ðŸ“‹ Background tasks scheduled for manual execution\")\n    \n    def __repr__(self):\n        return (f\"<UnifiedOscillatorNetworkManager '{self.manager_name}' \"\n                f\"networks={len(self.networks)} oscillators={self.total_oscillators} \"\n                f\"coherence={self.global_phase_coherence:.3f}>\")\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# UTILITY FUNCTIONS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\ndef create_oscillator_network_manager(base_path: str = \"/tmp\") -> UnifiedOscillatorNetworkManager:\n    \"\"\"Create and initialize an oscillator network manager\"\"\"\n    manager = UnifiedOscillatorNetworkManager(base_path, \"production_oscillator_manager\")\n    \n    logger.info(f\"ðŸŒŠ Oscillator Network Manager created with {len(manager.networks)} networks\")\n    return manager\n\ndef validate_oscillator_network_manager(manager: UnifiedOscillatorNetworkManager) -> Dict[str, Any]:\n    \"\"\"Comprehensive validation of oscillator network manager\"\"\"\n    validation = {\n        'status': 'unknown',\n        'issues': [],\n        'manager_status': manager.get_manager_status()\n    }\n    \n    try:\n        status = validation['manager_status']\n        \n        # Check overall health\n        if status['healthy_networks'] < status['total_networks']:\n            unhealthy = status['total_networks'] - status['healthy_networks']\n            validation['issues'].append(f\"{unhealthy} unhealthy networks detected\")\n        \n        # Check global coherence\n        if status['global_phase_coherence'] < 0.0 or status['global_phase_coherence'] > 1.0:\n            validation['issues'].append(f\"Invalid global coherence: {status['global_phase_coherence']}\")\n        \n        # Overall status\n        if not validation['issues']:\n            validation['status'] = 'excellent'\n        elif len(validation['issues']) <= 2:\n            validation['status'] = 'good'\n        else:\n            validation['status'] = 'issues_detected'\n        \n        return validation\n        \n    except Exception as e:\n        validation['status'] = 'error'\n        validation['issues'].append(f\"Validation failed: {e}\")\n        return validation\n\n# Export all components\n__all__ = [\n    'UnifiedOscillatorNetworkManager',\n    'NetworkTopology',\n    'NetworkState', \n    'OscillatorNetworkInfo',\n    'create_oscillator_network_manager',\n    'validate_oscillator_network_manager',\n    'BPS_CONFIG_AVAILABLE'\n]\n\nif __name__ == \"__main__\":\n    # ðŸŽª DEMONSTRATION MODE!\n    logger.info(\"ðŸš€ UNIFIED OSCILLATOR NETWORK MANAGER SYSTEM ACTIVATED!\")\n    logger.info(f\"âš¡ Config: {'CENTRALIZED' if BPS_CONFIG_AVAILABLE else 'FALLBACK MODE'}\")\n    \n    import sys\n    if '--demo' in sys.argv:\n        logger.info(\"ðŸŽª Creating demo oscillator networks...\")\n        \n        manager = create_oscillator_network_manager()\n        \n        # Create different network topologies\n        manager.create_network(\"ring_net\", NetworkTopology.RING, size=20)\n        manager.create_network(\"grid_net\", NetworkTopology.GRID, size=25)\n        \n        logger.info(\"ðŸ“Š Manager Status:\")\n        status = manager.get_manager_status()\n        for key, value in status.items():\n            logger.info(f\"  {key}: {value}\")\n    \n    logger.info(\"ðŸŽ¯ Unified Oscillator Network Manager ready for PRODUCTION use!\")\n"
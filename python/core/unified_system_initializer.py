# üöÄ **UNIFIED SYSTEM INITIALIZER** üéõÔ∏è\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n# Master system initialization and coordination hub\n# Orchestrates startup of all BPS subsystems with centralized configuration\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nimport logging\nimport time\nimport threading\nfrom typing import Dict, List, Any, Optional, Union, Tuple, Set, Callable\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom enum import Enum\n\n# üåü EPIC BPS CONFIG INTEGRATION üåü\ntry:\n    from .bps_config import (\n        # System initialization flags\n        ENABLE_BPS_SYSTEM_INITIALIZATION, ENABLE_BPS_AUTO_DISCOVERY, ENABLE_BPS_HEALTH_MONITORING,\n        STRICT_BPS_MODE, ENABLE_DETAILED_LOGGING,\n        \n        # Initialization parameters\n        SYSTEM_STARTUP_TIMEOUT, SUBSYSTEM_STARTUP_TIMEOUT, MAX_SUBSYSTEM_COUNT,\n        \n        # System paths and defaults\n        DEFAULT_SYSTEM_BASE_PATH, DEFAULT_SYSTEM_NAME\n    )\n    \n    BPS_CONFIG_AVAILABLE = True\n    logger = logging.getLogger(__name__)\n    logger.info(\"üöÄ System Initializer using CENTRALIZED BPS configuration!\")\n    \nexcept ImportError:\n    logger = logging.getLogger(__name__)\n    logger.warning(\"‚ö†Ô∏è BPS config unavailable - using fallback constants\")\n    \n    # System flags (conservative defaults)\n    ENABLE_BPS_SYSTEM_INITIALIZATION = True\n    ENABLE_BPS_AUTO_DISCOVERY = True\n    ENABLE_BPS_HEALTH_MONITORING = True\n    STRICT_BPS_MODE = False\n    ENABLE_DETAILED_LOGGING = True\n    \n    # Timing parameters\n    SYSTEM_STARTUP_TIMEOUT = 300.0  # 5 minutes\n    SUBSYSTEM_STARTUP_TIMEOUT = 60.0  # 1 minute\n    MAX_SUBSYSTEM_COUNT = 50\n    \n    # Paths and defaults\n    DEFAULT_SYSTEM_BASE_PATH = \"/tmp/tori_system\"\n    DEFAULT_SYSTEM_NAME = \"unified_bps_system\"\n    \n    BPS_CONFIG_AVAILABLE = False\n\n# Import all our unified subsystems with graceful fallbacks\ntry:\n    from .unified_memory_orchestrator import (\n        UnifiedMemoryOrchestrator, \n        create_unified_memory_orchestrator\n    )\n    MEMORY_ORCHESTRATOR_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\"Unified Memory Orchestrator not available\")\n    MEMORY_ORCHESTRATOR_AVAILABLE = False\n    \n    class UnifiedMemoryOrchestrator:\n        def __init__(self, *args, **kwargs):\n            pass\n        def get_orchestrator_status(self):\n            return {'status': 'fallback'}\n    \n    def create_unified_memory_orchestrator(*args, **kwargs):\n        return UnifiedMemoryOrchestrator()\n\ntry:\n    from .unified_oscillator_network_manager import (\n        UnifiedOscillatorNetworkManager,\n        create_oscillator_network_manager\n    )\n    OSCILLATOR_MANAGER_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\"Unified Oscillator Network Manager not available\")\n    OSCILLATOR_MANAGER_AVAILABLE = False\n    \n    class UnifiedOscillatorNetworkManager:\n        def __init__(self, *args, **kwargs):\n            pass\n        def get_manager_status(self):\n            return {'status': 'fallback'}\n    \n    def create_oscillator_network_manager(*args, **kwargs):\n        return UnifiedOscillatorNetworkManager()\n\ntry:\n    from .unified_diagnostics_coordinator import (\n        UnifiedDiagnosticsCoordinator,\n        create_diagnostics_coordinator,\n        DiagnosticCategory,\n        DiagnosticLevel\n    )\n    DIAGNOSTICS_COORDINATOR_AVAILABLE = True\nexcept ImportError:\n    logger.warning(\"Unified Diagnostics Coordinator not available\")\n    DIAGNOSTICS_COORDINATOR_AVAILABLE = False\n    \n    class UnifiedDiagnosticsCoordinator:\n        def __init__(self, *args, **kwargs):\n            pass\n        def get_coordinator_status(self):\n            return {'status': 'fallback'}\n        def register_subsystem(self, name, instance):\n            pass\n        def perform_health_check(self):\n            return {'status': 'fallback'}\n    \n    def create_diagnostics_coordinator(*args, **kwargs):\n        return UnifiedDiagnosticsCoordinator()\n\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n# SYSTEM STATE AND SUBSYSTEM TRACKING\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nclass SystemState(Enum):\n    \"\"\"Overall system states\"\"\"\n    UNINITIALIZED = \"uninitialized\"\n    INITIALIZING = \"initializing\"\n    RUNNING = \"running\"\n    DEGRADED = \"degraded\"\n    SHUTDOWN = \"shutdown\"\n    ERROR = \"error\"\n\nclass SubsystemState(Enum):\n    \"\"\"Individual subsystem states\"\"\"\n    NOT_STARTED = \"not_started\"\n    STARTING = \"starting\"\n    RUNNING = \"running\"\n    ERROR = \"error\"\n    SHUTDOWN = \"shutdown\"\n\n@dataclass\nclass SubsystemInfo:\n    \"\"\"Information about a registered subsystem\"\"\"\n    name: str\n    subsystem_type: str\n    instance: Any\n    state: SubsystemState = SubsystemState.NOT_STARTED\n    startup_time: Optional[float] = None\n    error_count: int = 0\n    last_error: Optional[str] = None\n\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n# UNIFIED SYSTEM INITIALIZER\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\nclass UnifiedSystemInitializer:\n    \"\"\"\n    üöÄ UNIFIED SYSTEM INITIALIZER - THE MASTER COORDINATOR! üéõÔ∏è\n    \n    Features:\n    ‚Ä¢ Orchestrates startup of all BPS subsystems\n    ‚Ä¢ Provides centralized health monitoring\n    ‚Ä¢ Handles graceful shutdown with proper cleanup\n    ‚Ä¢ Real-time system status and diagnostics\n    ‚Ä¢ Automatic subsystem discovery and registration\n    \"\"\"\n    \n    def __init__(self, system_name: str = None, base_path: Union[str, Path] = None):\n        \"\"\"\n        Initialize the unified system initializer\n        \n        Args:\n            system_name: Unique name for this system instance\n            base_path: Base directory for system storage\n        \"\"\"\n        self.system_name = system_name or DEFAULT_SYSTEM_NAME\n        self.base_path = Path(base_path or DEFAULT_SYSTEM_BASE_PATH)\n        self.system_path = self.base_path / self.system_name\n        \n        # üéõÔ∏è Configuration\n        self.config_available = BPS_CONFIG_AVAILABLE\n        self.strict_mode = STRICT_BPS_MODE\n        \n        # üîß System state\n        self.state = SystemState.UNINITIALIZED\n        self.subsystems: Dict[str, SubsystemInfo] = {}\n        \n        # ‚è±Ô∏è Timing tracking\n        self.creation_time = time.time()\n        self.startup_time: Optional[float] = None\n        \n        # üîí Thread safety\n        self.lock = threading.RLock()\n        \n        # üìä Monitoring\n        self.diagnostics_coordinator: Optional[UnifiedDiagnosticsCoordinator] = None\n        \n        # üéØ Performance tracking\n        self.initialization_count = 0\n        self.health_check_count = 0\n        \n        # Initialize system\n        self._initialize_system()\n        \n        logger.info(f\"üöÄ System Initializer '{self.system_name}' CREATED!\")\n        logger.info(f\"üìç Location: {self.system_path}\")\n        logger.info(f\"‚ö° BPS Config: {'ENABLED' if self.config_available else 'FALLBACK'}\")\n    \n    def _initialize_system(self):\n        \"\"\"Initialize system directory and basic setup\"\"\"\n        try:\n            self.system_path.mkdir(parents=True, exist_ok=True)\n            \n            # Create subdirectories\n            (self.system_path / \"subsystems\").mkdir(exist_ok=True)\n            (self.system_path / \"logs\").mkdir(exist_ok=True)\n            (self.system_path / \"config\").mkdir(exist_ok=True)\n            \n            logger.info(f\"üìÅ System directory structure initialized\")\n            \n        except Exception as e:\n            logger.error(f\"Failed to initialize system: {e}\")\n            if self.strict_mode:\n                raise RuntimeError(f\"System initialization failed: {e}\")\n    \n    def auto_discover_subsystems(self) -> Dict[str, bool]:\n        \"\"\"Automatically discover and register standard subsystems\"\"\"\n        if not ENABLE_BPS_AUTO_DISCOVERY:\n            logger.info(\"Auto-discovery disabled\")\n            return {}\n        \n        discovery_results = {}\n        \n        logger.info(\"üîç Starting auto-discovery of BPS subsystems...\")\n        \n        # Discover Diagnostics Coordinator\n        if DIAGNOSTICS_COORDINATOR_AVAILABLE:\n            try:\n                subsystem_path = self.system_path / \"subsystems\"\n                instance = create_diagnostics_coordinator(subsystem_path)\n                \n                info = SubsystemInfo(\n                    name=\"diagnostics_coordinator\",\n                    subsystem_type=\"diagnostics\",\n                    instance=instance\n                )\n                self.subsystems[\"diagnostics_coordinator\"] = info\n                discovery_results[\"diagnostics_coordinator\"] = True\n                logger.info(\"‚úÖ Diagnostics Coordinator discovered\")\n            except Exception as e:\n                logger.warning(f\"Failed to discover diagnostics coordinator: {e}\")\n                discovery_results[\"diagnostics_coordinator\"] = False\n        \n        # Discover Memory Orchestrator\n        if MEMORY_ORCHESTRATOR_AVAILABLE:\n            try:\n                subsystem_path = self.system_path / \"subsystems\"\n                instance = create_unified_memory_orchestrator(subsystem_path)\n                \n                info = SubsystemInfo(\n                    name=\"memory_orchestrator\",\n                    subsystem_type=\"memory\",\n                    instance=instance\n                )\n                self.subsystems[\"memory_orchestrator\"] = info\n                discovery_results[\"memory_orchestrator\"] = True\n                logger.info(\"‚úÖ Memory Orchestrator discovered\")\n            except Exception as e:\n                logger.warning(f\"Failed to discover memory orchestrator: {e}\")\n                discovery_results[\"memory_orchestrator\"] = False\n        \n        # Discover Oscillator Network Manager\n        if OSCILLATOR_MANAGER_AVAILABLE:\n            try:\n                subsystem_path = self.system_path / \"subsystems\"\n                instance = create_oscillator_network_manager(subsystem_path)\n                \n                info = SubsystemInfo(\n                    name=\"oscillator_manager\",\n                    subsystem_type=\"oscillator\",\n                    instance=instance\n                )\n                self.subsystems[\"oscillator_manager\"] = info\n                discovery_results[\"oscillator_manager\"] = True\n                logger.info(\"‚úÖ Oscillator Network Manager discovered\")\n            except Exception as e:\n                logger.warning(f\"Failed to discover oscillator manager: {e}\")\n                discovery_results[\"oscillator_manager\"] = False\n        \n        discovered_count = sum(discovery_results.values())\n        logger.info(f\"üîç Auto-discovery complete: {discovered_count}/{len(discovery_results)} subsystems\")\n        \n        return discovery_results\n    \n    def start_system(self, auto_discover: bool = True) -> bool:\n        \"\"\"Start the entire system with all subsystems\"\"\"\n        if not ENABLE_BPS_SYSTEM_INITIALIZATION:\n            logger.warning(\"System initialization disabled\")\n            return False\n        \n        with self.lock:\n            if self.state != SystemState.UNINITIALIZED:\n                logger.warning(f\"System already in state: {self.state.value}\")\n                return False\n            \n            logger.info(\"üöÄ STARTING UNIFIED BPS SYSTEM...\")\n            self.state = SystemState.INITIALIZING\n            \n            try:\n                # Auto-discover subsystems if requested\n                if auto_discover:\n                    self.auto_discover_subsystems()\n                \n                if not self.subsystems:\n                    logger.error(\"No subsystems registered - cannot start system\")\n                    self.state = SystemState.ERROR\n                    return False\n                \n                # Start subsystems\n                failed_subsystems = []\n                \n                for name, info in self.subsystems.items():\n                    success = self._start_subsystem(name)\n                    if not success:\n                        failed_subsystems.append(name)\n                        \n                        if self.strict_mode:\n                            logger.error(f\"Critical failure starting {name} in strict mode\")\n                            self.state = SystemState.ERROR\n                            return False\n                \n                # Register subsystems with diagnostics coordinator\n                self._register_with_diagnostics()\n                \n                # Determine final state\n                if not failed_subsystems:\n                    self.state = SystemState.RUNNING\n                    logger.info(\"üéâ SYSTEM STARTUP COMPLETE - ALL SYSTEMS OPERATIONAL!\")\n                elif len(failed_subsystems) < len(self.subsystems):\n                    self.state = SystemState.DEGRADED\n                    logger.warning(f\"‚ö†Ô∏è System started in degraded mode - {len(failed_subsystems)} failures\")\n                else:\n                    self.state = SystemState.ERROR\n                    logger.error(\"üí• System startup failed - all subsystems failed\")\n                    return False\n                \n                self.startup_time = time.time()\n                self.initialization_count += 1\n                \n                return True\n                \n            except Exception as e:\n                logger.error(f\"System startup failed: {e}\")\n                self.state = SystemState.ERROR\n                return False\n    \n    def _start_subsystem(self, subsystem_name: str) -> bool:\n        \"\"\"Start a specific subsystem\"\"\"\n        subsystem_info = self.subsystems[subsystem_name]\n        \n        logger.info(f\"üîß Starting subsystem: {subsystem_name}\")\n        \n        try:\n            subsystem_info.state = SubsystemState.STARTING\n            \n            # Subsystem-specific startup procedures would go here\n            # For now, we assume subsystems are created in running state\n            \n            subsystem_info.state = SubsystemState.RUNNING\n            subsystem_info.startup_time = time.time()\n            \n            logger.info(f\"‚úÖ Subsystem {subsystem_name} started successfully\")\n            return True\n            \n        except Exception as e:\n            subsystem_info.error_count += 1\n            subsystem_info.last_error = str(e)\n            subsystem_info.state = SubsystemState.ERROR\n            \n            logger.error(f\"‚ùå Failed to start subsystem {subsystem_name}: {e}\")\n            return False\n    \n    def _register_with_diagnostics(self):\n        \"\"\"Register all subsystems with the diagnostics coordinator\"\"\"\n        if \"diagnostics_coordinator\" not in self.subsystems:\n            return\n        \n        diagnostics = self.subsystems[\"diagnostics_coordinator\"].instance\n        self.diagnostics_coordinator = diagnostics\n        \n        # Register all other subsystems\n        for name, info in self.subsystems.items():\n            if name != \"diagnostics_coordinator\" and info.state == SubsystemState.RUNNING:\n                try:\n                    diagnostics.register_subsystem(name, info.instance)\n                    logger.debug(f\"üìä Registered {name} with diagnostics\")\n                except Exception as e:\n                    logger.warning(f\"Failed to register {name} with diagnostics: {e}\")\n    \n    def get_system_status(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive system status\"\"\"\n        with self.lock:\n            # Count subsystems by state\n            state_counts = {state.value: 0 for state in SubsystemState}\n            for info in self.subsystems.values():\n                state_counts[info.state.value] += 1\n            \n            # Calculate uptime\n            if self.startup_time:\n                uptime = time.time() - self.startup_time\n            else:\n                uptime = 0.0\n            \n            return {\n                'system_name': self.system_name,\n                'system_state': self.state.value,\n                'uptime_seconds': uptime,\n                'total_subsystems': len(self.subsystems),\n                'subsystem_state_counts': state_counts,\n                'initialization_count': self.initialization_count,\n                'health_check_count': self.health_check_count,\n                'startup_time': self.startup_time,\n                'config_available': self.config_available,\n                'strict_mode': self.strict_mode,\n                'subsystem_details': {\n                    name: {\n                        'type': info.subsystem_type,\n                        'state': info.state.value,\n                        'startup_time': info.startup_time,\n                        'error_count': info.error_count,\n                        'last_error': info.last_error\n                    }\n                    for name, info in self.subsystems.items()\n                }\n            }\n    \n    def shutdown_system(self) -> bool:\n        \"\"\"Shutdown the entire system\"\"\"\n        with self.lock:\n            if self.state in [SystemState.SHUTDOWN]:\n                logger.warning(f\"System already shutdown\")\n                return True\n            \n            logger.info(\"üõë SHUTTING DOWN UNIFIED BPS SYSTEM...\")\n            \n            try:\n                # Shutdown subsystems\n                for name, info in self.subsystems.items():\n                    if info.state == SubsystemState.RUNNING:\n                        info.state = SubsystemState.SHUTDOWN\n                        logger.info(f\"üîß Subsystem {name} shutdown\")\n                \n                self.state = SystemState.SHUTDOWN\n                \n                logger.info(\"‚úÖ SYSTEM SHUTDOWN COMPLETE\")\n                return True\n                \n            except Exception as e:\n                logger.error(f\"System shutdown failed: {e}\")\n                self.state = SystemState.ERROR\n                return False\n    \n    def __repr__(self):\n        return (f\"<UnifiedSystemInitializer '{self.system_name}' \"\n                f\"state={self.state.value} subsystems={len(self.subsystems)}>\")\n\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n# UTILITY FUNCTIONS\n# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\ndef create_production_system(system_name: str = None, base_path: str = None) -> UnifiedSystemInitializer:\n    \"\"\"Create and start a production BPS system\"\"\"\n    system = UnifiedSystemInitializer(system_name, base_path)\n    \n    # Start the system with auto-discovery\n    success = system.start_system(auto_discover=True)\n    \n    if success:\n        logger.info(f\"üéâ Production system '{system.system_name}' started successfully!\")\n        logger.info(f\"üìä System status: {system.state.value}\")\n        logger.info(f\"üîß Subsystems: {len(system.subsystems)}\")\n    else:\n        logger.error(f\"üí• Failed to start production system '{system.system_name}'\")\n    \n    return system\n\n# Export all components\n__all__ = [\n    'UnifiedSystemInitializer',\n    'SystemState',\n    'SubsystemState',\n    'SubsystemInfo',\n    'create_production_system',\n    'BPS_CONFIG_AVAILABLE'\n]\n\nif __name__ == \"__main__\":\n    # üé™ DEMONSTRATION AND PRODUCTION MODE!\n    logger.info(\"üöÄ UNIFIED SYSTEM INITIALIZER ACTIVATED!\")\n    logger.info(f\"‚ö° Config: {'CENTRALIZED' if BPS_CONFIG_AVAILABLE else 'FALLBACK MODE'}\")\n    \n    import sys\n    \n    if '--production' in sys.argv:\n        logger.info(\"üè≠ STARTING PRODUCTION SYSTEM...\")\n        \n        # Create and start production system\n        system = create_production_system(\"production_bps_system\")\n        \n        # Print system status\n        status = system.get_system_status()\n        logger.info(\"üìä PRODUCTION SYSTEM STATUS:\")\n        logger.info(f\"  System State: {status['system_state']}\")\n        logger.info(f\"  Subsystems: {status['total_subsystems']}\")\n        logger.info(f\"  Uptime: {status['uptime_seconds']:.1f}s\")\n        \n    elif '--demo' in sys.argv:\n        logger.info(\"üé™ Creating demo system...\")\n        \n        # Create demo system\n        system = UnifiedSystemInitializer(\"demo_system\")\n        \n        # Start with auto-discovery\n        success = system.start_system(auto_discover=True)\n        \n        if success:\n            logger.info(\"üìä Demo System Status:\")\n            status = system.get_system_status()\n            for key, value in status.items():\n                if key != 'subsystem_details':  # Skip detailed output\n                    logger.info(f\"  {key}: {value}\")\n            \n            # Shutdown after demo\n            logger.info(\"üõë Demo complete - shutting down...\")\n            system.shutdown_system()\n        else:\n            logger.error(\"üí• Demo system failed to start\")\n    \n    else:\n        logger.info(\"‚ÑπÔ∏è Usage: python unified_system_initializer.py [--production|--demo]\")\n        logger.info(\"  --production: Start production system\")\n        logger.info(\"  --demo: Run demonstration\")\n    \n    logger.info(\"üéØ Unified System Initializer ready for PRODUCTION use!\")\n"
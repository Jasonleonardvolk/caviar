#!/usr/bin/env python3
"""
Golden E2E Test for PsiArchive + Penrose
Ensures replay ‚â° live after every CI run
"""

import os
import sys
import json
import shutil
import tempfile
from pathlib import Path
from datetime import datetime
import subprocess
import hashlib

# Add project root to path
sys.path.append(str(Path(__file__).parent.parent))

from core.psi_archive_extended import EnhancedPsiArchiver
from penrose_projector.core import PenroseProjector
from concept_mesh.mesh import ConceptMesh


def hash_directory(path: Path) -> str:
    """Create a deterministic hash of directory contents"""
    hasher = hashlib.sha256()
    
    for file_path in sorted(path.rglob("*")):
        if file_path.is_file():
            # Add relative path to hash
            rel_path = file_path.relative_to(path)
            hasher.update(str(rel_path).encode())
            
            # Add file content to hash
            with open(file_path, 'rb') as f:
                hasher.update(f.read())
    
    return hasher.hexdigest()


def run_golden_test():
    """Run the golden e2e test"""
    print("üèÜ Running Golden E2E Test...")
    print("=" * 60)
    
    # Create temporary directories
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        test_archive_dir = temp_path / "test_archive"
        test_mesh_dir = temp_path / "test_mesh"
        replay_mesh_dir = temp_path / "replay_mesh"
        
        # Initialize fresh archive
        archiver = EnhancedPsiArchiver(str(test_archive_dir))
        
        # Initialize fresh concept mesh
        mesh = ConceptMesh(storage_path=str(test_mesh_dir))
        
        # Step 1: Ingest test PDF (create a minimal test document)
        test_doc = test_mesh_dir / "test_quantum.txt"
        test_doc.write_text("""
        Quantum Computing Fundamentals
        
        Quantum computing leverages quantum mechanical phenomena like superposition 
        and entanglement to process information. Unlike classical bits, quantum bits 
        (qubits) can exist in multiple states simultaneously.
        
        Key concepts:
        - Superposition: Qubits exist in probabilistic combinations of states
        - Entanglement: Correlated quantum states between multiple qubits
        - Quantum gates: Operations that manipulate qubit states
        - Decoherence: Loss of quantum properties due to environmental interaction
        """)
        
        print("\nüìù Step 1: Ingesting test document...")
        
        # Simulate concept extraction
        concepts = [
            {"id": "quantum_computing_001", "name": "Quantum Computing", "importance": 0.95},
            {"id": "superposition_001", "name": "Superposition", "importance": 0.9},
            {"id": "entanglement_001", "name": "Entanglement", "importance": 0.9},
            {"id": "qubit_001", "name": "Qubit", "importance": 0.85},
            {"id": "quantum_gate_001", "name": "Quantum Gate", "importance": 0.8},
            {"id": "decoherence_001", "name": "Decoherence", "importance": 0.75}
        ]
        
        # Add concepts to mesh
        for concept in concepts:
            mesh.add_concept(
                concept_id=concept["id"],
                name=concept["name"],
                category="physics",
                importance=concept["importance"],
                metadata={"source": "test_quantum.txt"}
            )
        
        # Add relationships
        mesh.add_relation("quantum_computing_001", "superposition_001", "USES", 0.9)
        mesh.add_relation("quantum_computing_001", "entanglement_001", "USES", 0.9)
        mesh.add_relation("quantum_computing_001", "qubit_001", "REQUIRES", 0.95)
        mesh.add_relation("qubit_001", "superposition_001", "EXHIBITS", 0.85)
        mesh.add_relation("qubit_001", "entanglement_001", "CAN_HAVE", 0.8)
        mesh.add_relation("decoherence_001", "quantum_computing_001", "LIMITS", 0.7)
        
        # Create mesh delta
        mesh_delta = {
            "added_nodes": [
                {
                    "id": c["id"],
                    "name": c["name"],
                    "category": "physics",
                    "importance": c["importance"]
                } for c in concepts
            ],
            "added_edges": [
                {"source": "quantum_computing_001", "target": "superposition_001", "relation_type": "USES", "strength": 0.9},
                {"source": "quantum_computing_001", "target": "entanglement_001", "relation_type": "USES", "strength": 0.9},
                {"source": "quantum_computing_001", "target": "qubit_001", "relation_type": "REQUIRES", "strength": 0.95},
                {"source": "qubit_001", "target": "superposition_001", "relation_type": "EXHIBITS", "strength": 0.85},
                {"source": "qubit_001", "target": "entanglement_001", "relation_type": "CAN_HAVE", "strength": 0.8},
                {"source": "decoherence_001", "target": "quantum_computing_001", "relation_type": "LIMITS", "strength": 0.7}
            ]
        }
        
        # Run Penrose projector
        print("\nüéØ Step 2: Running Penrose projection...")
        projector = PenroseProjector(rank=16, threshold=0.7, cache_dir=temp_path / "penrose_cache")
        
        # Create dummy embeddings for test
        import numpy as np
        np.random.seed(42)  # Deterministic
        embeddings = np.random.randn(len(concepts), 128)
        embeddings = embeddings / np.linalg.norm(embeddings, axis=1, keepdims=True)
        
        sparse_sim, stats = projector.compute_similarities(embeddings)
        
        # Log to archive with Penrose stats
        event_id = archiver.log_concept_ingestion(
            concept_ids=[c["id"] for c in concepts],
            source_doc_path=str(test_doc),
            session_id="test_session_001",
            mesh_delta=mesh_delta,
            tags=["physics", "quantum"],
            penrose_stats=stats
        )
        
        print(f"  ‚úÖ Logged ingestion event: {event_id}")
        print(f"  üìä Penrose stats: {stats['n_edges']} edges, {stats['speedup_vs_full']:.1f}x speedup")
        
        # Step 3: Create a response event
        print("\nüí¨ Step 3: Logging response generation...")
        response_id = archiver.log_response_generation(
            query="What is quantum entanglement?",
            concept_path=["quantum_computing_001", "entanglement_001"],
            response="Quantum entanglement is a phenomenon where quantum particles become correlated...",
            session_id="test_session_001",
            parent_plan_id=event_id,
            thread_id="test_thread_001"
        )
        
        print(f"  ‚úÖ Logged response event: {response_id}")
        
        # Force archive save
        archiver._save_daily_index()
        
        # Hash the live mesh
        live_hash = hash_directory(test_mesh_dir)
        print(f"\nüìÅ Live mesh hash: {live_hash[:16]}...")
        
        # Step 4: Replay from archive
        print("\nüîÑ Step 4: Replaying from archive...")
        
        # Run replay tool
        replay_cmd = [
            sys.executable,
            str(Path(__file__).parent / "psi_replay.py"),
            "--archive-dir", str(test_archive_dir),
            "--output-dir", str(replay_mesh_dir),
            "--until", "now"
        ]
        
        result = subprocess.run(replay_cmd, capture_output=True, text=True)
        if result.returncode != 0:
            print(f"  ‚ùå Replay failed: {result.stderr}")
            return False
        
        print("  ‚úÖ Replay completed")
        
        # Step 5: Compare meshes
        print("\nüîç Step 5: Comparing live vs replayed mesh...")
        
        replay_hash = hash_directory(replay_mesh_dir)
        print(f"  Replay mesh hash: {replay_hash[:16]}...")
        
        if live_hash == replay_hash:
            print("\n‚úÖ SUCCESS: Replay ‚â° Live! Archive is consistent.")
            
            # Show some stats
            archive_files = list(test_archive_dir.rglob("*.ndjson*"))
            total_size = sum(f.stat().st_size for f in archive_files)
            print(f"\nüìä Test Stats:")
            print(f"  - Archive files: {len(archive_files)}")
            print(f"  - Total size: {total_size / 1024:.1f} KB")
            print(f"  - Events logged: 2")
            print(f"  - Concepts: {len(concepts)}")
            print(f"  - Relations: 6")
            
            return True
        else:
            print("\n‚ùå FAILURE: Replay ‚â† Live! Archive replay differs.")
            
            # Debug: show differences
            live_files = set(f.relative_to(test_mesh_dir) for f in test_mesh_dir.rglob("*") if f.is_file())
            replay_files = set(f.relative_to(replay_mesh_dir) for f in replay_mesh_dir.rglob("*") if f.is_file())
            
            missing_in_replay = live_files - replay_files
            extra_in_replay = replay_files - live_files
            
            if missing_in_replay:
                print(f"\n  Missing in replay: {missing_in_replay}")
            if extra_in_replay:
                print(f"\n  Extra in replay: {extra_in_replay}")
            
            return False


if __name__ == "__main__":
    success = run_golden_test()
    sys.exit(0 if success else 1)

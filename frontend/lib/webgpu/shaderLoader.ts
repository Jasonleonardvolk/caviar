// frontend/lib/webgpu/shaderLoader.ts

export class ShaderLoader {
  private static cache = new Map<string, string>();
  private static bundle: any = null;
  private static bundlePromise: Promise<any> | null = null;

  private static async loadBundle(): Promise<any> {
    if (this.bundle) return this.bundle;
    
    if (!this.bundlePromise) {
      this.bundlePromise = import('./generated/shaderSources.js')
        .then(module => {
          this.bundle = module;
          return module;
        })
        .catch(() => {
          // File doesn't exist yet, will be generated by bundle-shaders
          console.warn('Shader bundle not found, falling back to file loading');
          return {};
        });
    }
    
    return this.bundlePromise;
  }

  static async load(shaderPath: string): Promise<string> {
    // Cache check
    if (this.cache.has(shaderPath)) return this.cache.get(shaderPath)!;

    // Extract just the filename for bundle lookup
    const filename = shaderPath.split('/').pop() || shaderPath;
    const key = filename.replace(/[-.]/g, '_').replace(/\.wgsl$/, '');
    
    // Try bundled shaders first
    const bundle = await this.loadBundle();
    if (bundle && bundle[key]) {
      const src = bundle[key] as string;
      this.cache.set(shaderPath, src);
      return src;
    }

    // Node environment - try file system
    if (typeof window === 'undefined') {
      // Dynamic imports for Node.js modules to avoid bundler issues
      try {
        const { readFileSync } = await import('node:fs');
        const { join } = await import('node:path');
        const projectRoot = process.cwd();
        const possiblePaths = [
          join(projectRoot, 'frontend', shaderPath),
          join(projectRoot, shaderPath),
          shaderPath
        ];
        
        for (const tryPath of possiblePaths) {
          try {
            const src = readFileSync(tryPath, 'utf8');
            this.cache.set(shaderPath, src);
            return src;
          } catch (e) {
            // Try next path
          }
        }
        
        throw new Error(`Shader not found: ${shaderPath} (tried ${possiblePaths.join(', ')})`);
      } catch (importError) {
        // If dynamic imports fail, fall through to browser fetch
        console.warn('Node.js modules not available, falling back to fetch');
      }
    }

    // Browser environment - fetch from server
    const url = shaderPath.startsWith('/') ? shaderPath : '/' + shaderPath;
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status} loading ${url}`);
      const src = await res.text();
      this.cache.set(shaderPath, src);
      return src;
    } catch (error) {
      throw new Error(`Failed to load shader ${shaderPath}: ${error}`);
    }
  }
  
  /**
   * Load shader synchronously from bundled sources only
   */
  static loadSync(path: string): string {
    // Check cache
    const cached = this.cache.get(path);
    if (cached) return cached;
    
    // Try bundled sources if already loaded
    if (this.bundle) {
      const key = path.split('/').pop()?.replace(/[-.]/g, '_').replace(/\.wgsl$/, '') || path.replace(/[-.]/g, '_');
      if (this.bundle[key]) {
        const src = this.bundle[key] as string;
        this.cache.set(path, src);
        return src;
      }
    }
    
    throw new Error(`Shader not found in bundle: ${path}`);
  }
  
  /**
   * Preload multiple shaders
   */
  static async preload(paths: string[]): Promise<void> {
    await Promise.all(paths.map(path => this.load(path)));
  }
  
  /**
   * Clear cache
   */
  static clearCache(): void {
    this.cache.clear();
  }
  
  /**
   * Get cache statistics
   */
  static getCacheStats(): { size: number; shaders: string[] } {
    return {
      size: this.cache.size,
      shaders: Array.from(this.cache.keys())
    };
  }
}

// Re-export for backward compatibility
export { ShaderLoader as default };
